// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vectorindex.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Vectorindex__Item {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var vector: Vectorindex__Vector {
    get {return _vector ?? Vectorindex__Vector()}
    set {_vector = newValue}
  }
  /// Returns true if `vector` has been explicitly set.
  public var hasVector: Bool {return self._vector != nil}
  /// Clears the value of `vector`. Subsequent reads from it will return its default value.
  public mutating func clearVector() {self._vector = nil}

  public var metadata: [Vectorindex__Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vector: Vectorindex__Vector? = nil
}

public struct Vectorindex__UpsertItemBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var items: [Vectorindex__Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__UpsertItemBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var errorIndices: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__DeleteItemBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__DeleteItemBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__Vector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var elements: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var value: Vectorindex__Metadata.OneOf_Value? = nil

  public var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  public var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = value {return v}
      return 0
    }
    set {value = .integerValue(newValue)}
  }

  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = value {return v}
      return 0
    }
    set {value = .doubleValue(newValue)}
  }

  public var booleanValue: Bool {
    get {
      if case .booleanValue(let v)? = value {return v}
      return false
    }
    set {value = .booleanValue(newValue)}
  }

  public var listOfStringsValue: Vectorindex__Metadata._ListOfStrings {
    get {
      if case .listOfStringsValue(let v)? = value {return v}
      return Vectorindex__Metadata._ListOfStrings()
    }
    set {value = .listOfStringsValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case stringValue(String)
    case integerValue(Int64)
    case doubleValue(Double)
    case booleanValue(Bool)
    case listOfStringsValue(Vectorindex__Metadata._ListOfStrings)

  #if !swift(>=4.1)
    public static func ==(lhs: Vectorindex__Metadata.OneOf_Value, rhs: Vectorindex__Metadata.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integerValue, .integerValue): return {
        guard case .integerValue(let l) = lhs, case .integerValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanValue, .booleanValue): return {
        guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listOfStringsValue, .listOfStringsValue): return {
        guard case .listOfStringsValue(let l) = lhs, case .listOfStringsValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _ListOfStrings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Vectorindex__MetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Vectorindex__MetadataRequest.OneOf_Kind? = nil

  public var some: Vectorindex__MetadataRequest.Some {
    get {
      if case .some(let v)? = kind {return v}
      return Vectorindex__MetadataRequest.Some()
    }
    set {kind = .some(newValue)}
  }

  public var all: Vectorindex__MetadataRequest.All {
    get {
      if case .all(let v)? = kind {return v}
      return Vectorindex__MetadataRequest.All()
    }
    set {kind = .all(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case some(Vectorindex__MetadataRequest.Some)
    case all(Vectorindex__MetadataRequest.All)

  #if !swift(>=4.1)
    public static func ==(lhs: Vectorindex__MetadataRequest.OneOf_Kind, rhs: Vectorindex__MetadataRequest.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.some, .some): return {
        guard case .some(let l) = lhs, case .some(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Some {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fields: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct All {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Vectorindex__NoScoreThreshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__SearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var topK: UInt32 = 0

  public var queryVector: Vectorindex__Vector {
    get {return _queryVector ?? Vectorindex__Vector()}
    set {_queryVector = newValue}
  }
  /// Returns true if `queryVector` has been explicitly set.
  public var hasQueryVector: Bool {return self._queryVector != nil}
  /// Clears the value of `queryVector`. Subsequent reads from it will return its default value.
  public mutating func clearQueryVector() {self._queryVector = nil}

  public var metadataFields: Vectorindex__MetadataRequest {
    get {return _metadataFields ?? Vectorindex__MetadataRequest()}
    set {_metadataFields = newValue}
  }
  /// Returns true if `metadataFields` has been explicitly set.
  public var hasMetadataFields: Bool {return self._metadataFields != nil}
  /// Clears the value of `metadataFields`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataFields() {self._metadataFields = nil}

  public var threshold: Vectorindex__SearchRequest.OneOf_Threshold? = nil

  public var scoreThreshold: Float {
    get {
      if case .scoreThreshold(let v)? = threshold {return v}
      return 0
    }
    set {threshold = .scoreThreshold(newValue)}
  }

  public var noScoreThreshold: Vectorindex__NoScoreThreshold {
    get {
      if case .noScoreThreshold(let v)? = threshold {return v}
      return Vectorindex__NoScoreThreshold()
    }
    set {threshold = .noScoreThreshold(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Threshold: Equatable {
    case scoreThreshold(Float)
    case noScoreThreshold(Vectorindex__NoScoreThreshold)

  #if !swift(>=4.1)
    public static func ==(lhs: Vectorindex__SearchRequest.OneOf_Threshold, rhs: Vectorindex__SearchRequest.OneOf_Threshold) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scoreThreshold, .scoreThreshold): return {
        guard case .scoreThreshold(let l) = lhs, case .scoreThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noScoreThreshold, .noScoreThreshold): return {
        guard case .noScoreThreshold(let l) = lhs, case .noScoreThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _queryVector: Vectorindex__Vector? = nil
  fileprivate var _metadataFields: Vectorindex__MetadataRequest? = nil
}

public struct Vectorindex__SearchAndFetchVectorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var topK: UInt32 = 0

  public var queryVector: Vectorindex__Vector {
    get {return _queryVector ?? Vectorindex__Vector()}
    set {_queryVector = newValue}
  }
  /// Returns true if `queryVector` has been explicitly set.
  public var hasQueryVector: Bool {return self._queryVector != nil}
  /// Clears the value of `queryVector`. Subsequent reads from it will return its default value.
  public mutating func clearQueryVector() {self._queryVector = nil}

  public var metadataFields: Vectorindex__MetadataRequest {
    get {return _metadataFields ?? Vectorindex__MetadataRequest()}
    set {_metadataFields = newValue}
  }
  /// Returns true if `metadataFields` has been explicitly set.
  public var hasMetadataFields: Bool {return self._metadataFields != nil}
  /// Clears the value of `metadataFields`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataFields() {self._metadataFields = nil}

  public var threshold: Vectorindex__SearchAndFetchVectorsRequest.OneOf_Threshold? = nil

  public var scoreThreshold: Float {
    get {
      if case .scoreThreshold(let v)? = threshold {return v}
      return 0
    }
    set {threshold = .scoreThreshold(newValue)}
  }

  public var noScoreThreshold: Vectorindex__NoScoreThreshold {
    get {
      if case .noScoreThreshold(let v)? = threshold {return v}
      return Vectorindex__NoScoreThreshold()
    }
    set {threshold = .noScoreThreshold(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Threshold: Equatable {
    case scoreThreshold(Float)
    case noScoreThreshold(Vectorindex__NoScoreThreshold)

  #if !swift(>=4.1)
    public static func ==(lhs: Vectorindex__SearchAndFetchVectorsRequest.OneOf_Threshold, rhs: Vectorindex__SearchAndFetchVectorsRequest.OneOf_Threshold) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scoreThreshold, .scoreThreshold): return {
        guard case .scoreThreshold(let l) = lhs, case .scoreThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noScoreThreshold, .noScoreThreshold): return {
        guard case .noScoreThreshold(let l) = lhs, case .noScoreThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _queryVector: Vectorindex__Vector? = nil
  fileprivate var _metadataFields: Vectorindex__MetadataRequest? = nil
}

public struct Vectorindex__SearchHit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var distance: Float = 0

  public var metadata: [Vectorindex__Metadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__SearchAndFetchVectorsHit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var distance: Float = 0

  public var metadata: [Vectorindex__Metadata] = []

  public var vector: Vectorindex__Vector {
    get {return _vector ?? Vectorindex__Vector()}
    set {_vector = newValue}
  }
  /// Returns true if `vector` has been explicitly set.
  public var hasVector: Bool {return self._vector != nil}
  /// Clears the value of `vector`. Subsequent reads from it will return its default value.
  public mutating func clearVector() {self._vector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vector: Vectorindex__Vector? = nil
}

public struct Vectorindex__SearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hits: [Vectorindex__SearchHit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__SearchAndFetchVectorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hits: [Vectorindex__SearchAndFetchVectorsHit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vectorindex__GetItemBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var ids: [String] = []

  public var metadataFields: Vectorindex__MetadataRequest {
    get {return _metadataFields ?? Vectorindex__MetadataRequest()}
    set {_metadataFields = newValue}
  }
  /// Returns true if `metadataFields` has been explicitly set.
  public var hasMetadataFields: Bool {return self._metadataFields != nil}
  /// Clears the value of `metadataFields`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataFields() {self._metadataFields = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadataFields: Vectorindex__MetadataRequest? = nil
}

public struct Vectorindex__ItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Vectorindex__ItemResponse.OneOf_Response? = nil

  public var miss: Vectorindex__ItemResponse._Miss {
    get {
      if case .miss(let v)? = response {return v}
      return Vectorindex__ItemResponse._Miss()
    }
    set {response = .miss(newValue)}
  }

  public var hit: Vectorindex__ItemResponse._Hit {
    get {
      if case .hit(let v)? = response {return v}
      return Vectorindex__ItemResponse._Hit()
    }
    set {response = .hit(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case miss(Vectorindex__ItemResponse._Miss)
    case hit(Vectorindex__ItemResponse._Hit)

  #if !swift(>=4.1)
    public static func ==(lhs: Vectorindex__ItemResponse.OneOf_Response, rhs: Vectorindex__ItemResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.miss, .miss): return {
        guard case .miss(let l) = lhs, case .miss(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hit, .hit): return {
        guard case .hit(let l) = lhs, case .hit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Miss {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Hit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var metadata: [Vectorindex__Metadata] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Vectorindex__GetItemBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemResponse: [Vectorindex__ItemResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Vectorindex__Item: @unchecked Sendable {}
extension Vectorindex__UpsertItemBatchRequest: @unchecked Sendable {}
extension Vectorindex__UpsertItemBatchResponse: @unchecked Sendable {}
extension Vectorindex__DeleteItemBatchRequest: @unchecked Sendable {}
extension Vectorindex__DeleteItemBatchResponse: @unchecked Sendable {}
extension Vectorindex__Vector: @unchecked Sendable {}
extension Vectorindex__Metadata: @unchecked Sendable {}
extension Vectorindex__Metadata.OneOf_Value: @unchecked Sendable {}
extension Vectorindex__Metadata._ListOfStrings: @unchecked Sendable {}
extension Vectorindex__MetadataRequest: @unchecked Sendable {}
extension Vectorindex__MetadataRequest.OneOf_Kind: @unchecked Sendable {}
extension Vectorindex__MetadataRequest.Some: @unchecked Sendable {}
extension Vectorindex__MetadataRequest.All: @unchecked Sendable {}
extension Vectorindex__NoScoreThreshold: @unchecked Sendable {}
extension Vectorindex__SearchRequest: @unchecked Sendable {}
extension Vectorindex__SearchRequest.OneOf_Threshold: @unchecked Sendable {}
extension Vectorindex__SearchAndFetchVectorsRequest: @unchecked Sendable {}
extension Vectorindex__SearchAndFetchVectorsRequest.OneOf_Threshold: @unchecked Sendable {}
extension Vectorindex__SearchHit: @unchecked Sendable {}
extension Vectorindex__SearchAndFetchVectorsHit: @unchecked Sendable {}
extension Vectorindex__SearchResponse: @unchecked Sendable {}
extension Vectorindex__SearchAndFetchVectorsResponse: @unchecked Sendable {}
extension Vectorindex__GetItemBatchRequest: @unchecked Sendable {}
extension Vectorindex__ItemResponse: @unchecked Sendable {}
extension Vectorindex__ItemResponse.OneOf_Response: @unchecked Sendable {}
extension Vectorindex__ItemResponse._Miss: @unchecked Sendable {}
extension Vectorindex__ItemResponse._Hit: @unchecked Sendable {}
extension Vectorindex__GetItemBatchResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vectorindex"

extension Vectorindex__Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "vector"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._vector) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._vector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__Item, rhs: Vectorindex__Item) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._vector != rhs._vector {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__UpsertItemBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._UpsertItemBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__UpsertItemBatchRequest, rhs: Vectorindex__UpsertItemBatchRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__UpsertItemBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._UpsertItemBatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.errorIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorIndices.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.errorIndices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__UpsertItemBatchResponse, rhs: Vectorindex__UpsertItemBatchResponse) -> Bool {
    if lhs.errorIndices != rhs.errorIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__DeleteItemBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteItemBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__DeleteItemBatchRequest, rhs: Vectorindex__DeleteItemBatchRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__DeleteItemBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteItemBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__DeleteItemBatchResponse, rhs: Vectorindex__DeleteItemBatchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__Vector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Vector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitPackedFloatField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__Vector, rhs: Vectorindex__Vector) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .standard(proto: "string_value"),
    3: .standard(proto: "integer_value"),
    4: .standard(proto: "double_value"),
    5: .standard(proto: "boolean_value"),
    6: .standard(proto: "list_of_strings_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integerValue(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .doubleValue(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .booleanValue(v)
        }
      }()
      case 6: try {
        var v: Vectorindex__Metadata._ListOfStrings?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .listOfStringsValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .listOfStringsValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .listOfStringsValue?: try {
      guard case .listOfStringsValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__Metadata, rhs: Vectorindex__Metadata) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__Metadata._ListOfStrings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vectorindex__Metadata.protoMessageName + "._ListOfStrings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__Metadata._ListOfStrings, rhs: Vectorindex__Metadata._ListOfStrings) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__MetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._MetadataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "some"),
    3: .same(proto: "all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Vectorindex__MetadataRequest.Some?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .some(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .some(v)
        }
      }()
      case 3: try {
        var v: Vectorindex__MetadataRequest.All?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .some?: try {
      guard case .some(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .all?: try {
      guard case .all(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__MetadataRequest, rhs: Vectorindex__MetadataRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__MetadataRequest.Some: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vectorindex__MetadataRequest.protoMessageName + ".Some"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__MetadataRequest.Some, rhs: Vectorindex__MetadataRequest.Some) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__MetadataRequest.All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vectorindex__MetadataRequest.protoMessageName + ".All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__MetadataRequest.All, rhs: Vectorindex__MetadataRequest.All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__NoScoreThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._NoScoreThreshold"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__NoScoreThreshold, rhs: Vectorindex__NoScoreThreshold) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .standard(proto: "top_k"),
    3: .standard(proto: "query_vector"),
    4: .standard(proto: "metadata_fields"),
    5: .standard(proto: "score_threshold"),
    6: .standard(proto: "no_score_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.topK) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._queryVector) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataFields) }()
      case 5: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.threshold != nil {try decoder.handleConflictingOneOf()}
          self.threshold = .scoreThreshold(v)
        }
      }()
      case 6: try {
        var v: Vectorindex__NoScoreThreshold?
        var hadOneofValue = false
        if let current = self.threshold {
          hadOneofValue = true
          if case .noScoreThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.threshold = .noScoreThreshold(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if self.topK != 0 {
      try visitor.visitSingularUInt32Field(value: self.topK, fieldNumber: 2)
    }
    try { if let v = self._queryVector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._metadataFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.threshold {
    case .scoreThreshold?: try {
      guard case .scoreThreshold(let v)? = self.threshold else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }()
    case .noScoreThreshold?: try {
      guard case .noScoreThreshold(let v)? = self.threshold else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchRequest, rhs: Vectorindex__SearchRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.topK != rhs.topK {return false}
    if lhs._queryVector != rhs._queryVector {return false}
    if lhs._metadataFields != rhs._metadataFields {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchAndFetchVectorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchAndFetchVectorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .standard(proto: "top_k"),
    3: .standard(proto: "query_vector"),
    4: .standard(proto: "metadata_fields"),
    5: .standard(proto: "score_threshold"),
    6: .standard(proto: "no_score_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.topK) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._queryVector) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataFields) }()
      case 5: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.threshold != nil {try decoder.handleConflictingOneOf()}
          self.threshold = .scoreThreshold(v)
        }
      }()
      case 6: try {
        var v: Vectorindex__NoScoreThreshold?
        var hadOneofValue = false
        if let current = self.threshold {
          hadOneofValue = true
          if case .noScoreThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.threshold = .noScoreThreshold(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if self.topK != 0 {
      try visitor.visitSingularUInt32Field(value: self.topK, fieldNumber: 2)
    }
    try { if let v = self._queryVector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._metadataFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.threshold {
    case .scoreThreshold?: try {
      guard case .scoreThreshold(let v)? = self.threshold else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }()
    case .noScoreThreshold?: try {
      guard case .noScoreThreshold(let v)? = self.threshold else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchAndFetchVectorsRequest, rhs: Vectorindex__SearchAndFetchVectorsRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.topK != rhs.topK {return false}
    if lhs._queryVector != rhs._queryVector {return false}
    if lhs._metadataFields != rhs._metadataFields {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchHit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchHit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "distance"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.distance) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.distance != 0 {
      try visitor.visitSingularFloatField(value: self.distance, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchHit, rhs: Vectorindex__SearchHit) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchAndFetchVectorsHit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchAndFetchVectorsHit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "distance"),
    3: .same(proto: "metadata"),
    4: .same(proto: "vector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.distance) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._vector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.distance != 0 {
      try visitor.visitSingularFloatField(value: self.distance, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 3)
    }
    try { if let v = self._vector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchAndFetchVectorsHit, rhs: Vectorindex__SearchAndFetchVectorsHit) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._vector != rhs._vector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchResponse, rhs: Vectorindex__SearchResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__SearchAndFetchVectorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SearchAndFetchVectorsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__SearchAndFetchVectorsResponse, rhs: Vectorindex__SearchAndFetchVectorsResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__GetItemBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._GetItemBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .same(proto: "ids"),
    3: .standard(proto: "metadata_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadataFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 2)
    }
    try { if let v = self._metadataFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__GetItemBatchRequest, rhs: Vectorindex__GetItemBatchRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs._metadataFields != rhs._metadataFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__ItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ItemResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "miss"),
    2: .same(proto: "hit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Vectorindex__ItemResponse._Miss?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .miss(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .miss(v)
        }
      }()
      case 2: try {
        var v: Vectorindex__ItemResponse._Hit?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .hit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .hit(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .miss?: try {
      guard case .miss(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .hit?: try {
      guard case .hit(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__ItemResponse, rhs: Vectorindex__ItemResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__ItemResponse._Miss: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vectorindex__ItemResponse.protoMessageName + "._Miss"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__ItemResponse._Miss, rhs: Vectorindex__ItemResponse._Miss) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__ItemResponse._Hit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Vectorindex__ItemResponse.protoMessageName + "._Hit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__ItemResponse._Hit, rhs: Vectorindex__ItemResponse._Hit) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vectorindex__GetItemBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._GetItemBatchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.itemResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.itemResponse.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemResponse, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vectorindex__GetItemBatchResponse, rhs: Vectorindex__GetItemBatchResponse) -> Bool {
    if lhs.itemResponse != rhs.itemResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
