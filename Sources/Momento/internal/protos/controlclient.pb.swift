// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: controlclient.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ControlClient__CreateIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var numDimensions: UInt64 = 0

  public var similarityMetric: ControlClient__CreateIndexRequest.OneOf_SimilarityMetric? = nil

  public var euclideanSimilarity: ControlClient__CreateIndexRequest._EuclideanSimilarity {
    get {
      if case .euclideanSimilarity(let v)? = similarityMetric {return v}
      return ControlClient__CreateIndexRequest._EuclideanSimilarity()
    }
    set {similarityMetric = .euclideanSimilarity(newValue)}
  }

  public var innerProduct: ControlClient__CreateIndexRequest._InnerProduct {
    get {
      if case .innerProduct(let v)? = similarityMetric {return v}
      return ControlClient__CreateIndexRequest._InnerProduct()
    }
    set {similarityMetric = .innerProduct(newValue)}
  }

  public var cosineSimilarity: ControlClient__CreateIndexRequest._CosineSimilarity {
    get {
      if case .cosineSimilarity(let v)? = similarityMetric {return v}
      return ControlClient__CreateIndexRequest._CosineSimilarity()
    }
    set {similarityMetric = .cosineSimilarity(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SimilarityMetric: Equatable {
    case euclideanSimilarity(ControlClient__CreateIndexRequest._EuclideanSimilarity)
    case innerProduct(ControlClient__CreateIndexRequest._InnerProduct)
    case cosineSimilarity(ControlClient__CreateIndexRequest._CosineSimilarity)

  #if !swift(>=4.1)
    public static func ==(lhs: ControlClient__CreateIndexRequest.OneOf_SimilarityMetric, rhs: ControlClient__CreateIndexRequest.OneOf_SimilarityMetric) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.euclideanSimilarity, .euclideanSimilarity): return {
        guard case .euclideanSimilarity(let l) = lhs, case .euclideanSimilarity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.innerProduct, .innerProduct): return {
        guard case .innerProduct(let l) = lhs, case .innerProduct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cosineSimilarity, .cosineSimilarity): return {
        guard case .cosineSimilarity(let l) = lhs, case .cosineSimilarity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _EuclideanSimilarity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _InnerProduct {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _CosineSimilarity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct ControlClient__CreateIndexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__DeleteIndexRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__DeleteIndexResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__ListIndexesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__ListIndexesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var indexNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__DeleteCacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__DeleteCacheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__CreateCacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__CreateCacheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__ListCachesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nextToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__CacheLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of transactions per second that can be exercised
  public var maxTrafficRate: UInt32 = 0

  /// The amount of traffic per second that can be exercised in KiB
  public var maxThroughputKbps: UInt32 = 0

  /// The maximum size of a single item in KiB
  public var maxItemSizeKb: UInt32 = 0

  /// The maximum TTL allowed for a single item, in seconds
  public var maxTtlSeconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__TopicLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of messages that can be published per second
  public var maxPublishRate: UInt32 = 0

  /// The maximum amount of active subscriptions per cache
  public var maxSubscriptionCount: UInt32 = 0

  /// The maximum size of a single publish message, in KiB
  public var maxPublishMessageSizeKb: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__Cache {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheName: String = String()

  public var cacheLimits: ControlClient__CacheLimits {
    get {return _cacheLimits ?? ControlClient__CacheLimits()}
    set {_cacheLimits = newValue}
  }
  /// Returns true if `cacheLimits` has been explicitly set.
  public var hasCacheLimits: Bool {return self._cacheLimits != nil}
  /// Clears the value of `cacheLimits`. Subsequent reads from it will return its default value.
  public mutating func clearCacheLimits() {self._cacheLimits = nil}

  public var topicLimits: ControlClient__TopicLimits {
    get {return _topicLimits ?? ControlClient__TopicLimits()}
    set {_topicLimits = newValue}
  }
  /// Returns true if `topicLimits` has been explicitly set.
  public var hasTopicLimits: Bool {return self._topicLimits != nil}
  /// Clears the value of `topicLimits`. Subsequent reads from it will return its default value.
  public mutating func clearTopicLimits() {self._topicLimits = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cacheLimits: ControlClient__CacheLimits? = nil
  fileprivate var _topicLimits: ControlClient__TopicLimits? = nil
}

public struct ControlClient__ListCachesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cache: [ControlClient__Cache] = []

  public var nextToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__CreateSigningKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ttlMinutes: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__CreateSigningKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var expiresAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__RevokeSigningKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__RevokeSigningKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__SigningKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the signing key
  public var keyID: String = String()

  /// Epoch time in seconds when the signing key expires
  public var expiresAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__ListSigningKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nextToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__ListSigningKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signingKey: [ControlClient__SigningKey] = []

  public var nextToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__FlushCacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ControlClient__FlushCacheResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ControlClient__CreateIndexRequest: @unchecked Sendable {}
extension ControlClient__CreateIndexRequest.OneOf_SimilarityMetric: @unchecked Sendable {}
extension ControlClient__CreateIndexRequest._EuclideanSimilarity: @unchecked Sendable {}
extension ControlClient__CreateIndexRequest._InnerProduct: @unchecked Sendable {}
extension ControlClient__CreateIndexRequest._CosineSimilarity: @unchecked Sendable {}
extension ControlClient__CreateIndexResponse: @unchecked Sendable {}
extension ControlClient__DeleteIndexRequest: @unchecked Sendable {}
extension ControlClient__DeleteIndexResponse: @unchecked Sendable {}
extension ControlClient__ListIndexesRequest: @unchecked Sendable {}
extension ControlClient__ListIndexesResponse: @unchecked Sendable {}
extension ControlClient__DeleteCacheRequest: @unchecked Sendable {}
extension ControlClient__DeleteCacheResponse: @unchecked Sendable {}
extension ControlClient__CreateCacheRequest: @unchecked Sendable {}
extension ControlClient__CreateCacheResponse: @unchecked Sendable {}
extension ControlClient__ListCachesRequest: @unchecked Sendable {}
extension ControlClient__CacheLimits: @unchecked Sendable {}
extension ControlClient__TopicLimits: @unchecked Sendable {}
extension ControlClient__Cache: @unchecked Sendable {}
extension ControlClient__ListCachesResponse: @unchecked Sendable {}
extension ControlClient__CreateSigningKeyRequest: @unchecked Sendable {}
extension ControlClient__CreateSigningKeyResponse: @unchecked Sendable {}
extension ControlClient__RevokeSigningKeyRequest: @unchecked Sendable {}
extension ControlClient__RevokeSigningKeyResponse: @unchecked Sendable {}
extension ControlClient__SigningKey: @unchecked Sendable {}
extension ControlClient__ListSigningKeysRequest: @unchecked Sendable {}
extension ControlClient__ListSigningKeysResponse: @unchecked Sendable {}
extension ControlClient__FlushCacheRequest: @unchecked Sendable {}
extension ControlClient__FlushCacheResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "control_client"

extension ControlClient__CreateIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
    2: .standard(proto: "num_dimensions"),
    3: .standard(proto: "euclidean_similarity"),
    4: .standard(proto: "inner_product"),
    5: .standard(proto: "cosine_similarity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numDimensions) }()
      case 3: try {
        var v: ControlClient__CreateIndexRequest._EuclideanSimilarity?
        var hadOneofValue = false
        if let current = self.similarityMetric {
          hadOneofValue = true
          if case .euclideanSimilarity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.similarityMetric = .euclideanSimilarity(v)
        }
      }()
      case 4: try {
        var v: ControlClient__CreateIndexRequest._InnerProduct?
        var hadOneofValue = false
        if let current = self.similarityMetric {
          hadOneofValue = true
          if case .innerProduct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.similarityMetric = .innerProduct(v)
        }
      }()
      case 5: try {
        var v: ControlClient__CreateIndexRequest._CosineSimilarity?
        var hadOneofValue = false
        if let current = self.similarityMetric {
          hadOneofValue = true
          if case .cosineSimilarity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.similarityMetric = .cosineSimilarity(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    if self.numDimensions != 0 {
      try visitor.visitSingularUInt64Field(value: self.numDimensions, fieldNumber: 2)
    }
    switch self.similarityMetric {
    case .euclideanSimilarity?: try {
      guard case .euclideanSimilarity(let v)? = self.similarityMetric else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .innerProduct?: try {
      guard case .innerProduct(let v)? = self.similarityMetric else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .cosineSimilarity?: try {
      guard case .cosineSimilarity(let v)? = self.similarityMetric else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateIndexRequest, rhs: ControlClient__CreateIndexRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.numDimensions != rhs.numDimensions {return false}
    if lhs.similarityMetric != rhs.similarityMetric {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateIndexRequest._EuclideanSimilarity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ControlClient__CreateIndexRequest.protoMessageName + "._EuclideanSimilarity"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateIndexRequest._EuclideanSimilarity, rhs: ControlClient__CreateIndexRequest._EuclideanSimilarity) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateIndexRequest._InnerProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ControlClient__CreateIndexRequest.protoMessageName + "._InnerProduct"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateIndexRequest._InnerProduct, rhs: ControlClient__CreateIndexRequest._InnerProduct) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateIndexRequest._CosineSimilarity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ControlClient__CreateIndexRequest.protoMessageName + "._CosineSimilarity"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateIndexRequest._CosineSimilarity, rhs: ControlClient__CreateIndexRequest._CosineSimilarity) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateIndexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateIndexResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateIndexResponse, rhs: ControlClient__CreateIndexResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__DeleteIndexRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteIndexRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.indexName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexName.isEmpty {
      try visitor.visitSingularStringField(value: self.indexName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__DeleteIndexRequest, rhs: ControlClient__DeleteIndexRequest) -> Bool {
    if lhs.indexName != rhs.indexName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__DeleteIndexResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteIndexResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__DeleteIndexResponse, rhs: ControlClient__DeleteIndexResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListIndexesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListIndexesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListIndexesRequest, rhs: ControlClient__ListIndexesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListIndexesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListIndexesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.indexNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.indexNames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListIndexesResponse, rhs: ControlClient__ListIndexesResponse) -> Bool {
    if lhs.indexNames != rhs.indexNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__DeleteCacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteCacheRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__DeleteCacheRequest, rhs: ControlClient__DeleteCacheRequest) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__DeleteCacheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteCacheResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__DeleteCacheResponse, rhs: ControlClient__DeleteCacheResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateCacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateCacheRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateCacheRequest, rhs: ControlClient__CreateCacheRequest) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateCacheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateCacheResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateCacheResponse, rhs: ControlClient__CreateCacheResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListCachesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListCachesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListCachesRequest, rhs: ControlClient__ListCachesRequest) -> Bool {
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CacheLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CacheLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_traffic_rate"),
    2: .standard(proto: "max_throughput_kbps"),
    3: .standard(proto: "max_item_size_kb"),
    4: .standard(proto: "max_ttl_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxTrafficRate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxThroughputKbps) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxItemSizeKb) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.maxTtlSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTrafficRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTrafficRate, fieldNumber: 1)
    }
    if self.maxThroughputKbps != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxThroughputKbps, fieldNumber: 2)
    }
    if self.maxItemSizeKb != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxItemSizeKb, fieldNumber: 3)
    }
    if self.maxTtlSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxTtlSeconds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CacheLimits, rhs: ControlClient__CacheLimits) -> Bool {
    if lhs.maxTrafficRate != rhs.maxTrafficRate {return false}
    if lhs.maxThroughputKbps != rhs.maxThroughputKbps {return false}
    if lhs.maxItemSizeKb != rhs.maxItemSizeKb {return false}
    if lhs.maxTtlSeconds != rhs.maxTtlSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__TopicLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._TopicLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_publish_rate"),
    2: .standard(proto: "max_subscription_count"),
    3: .standard(proto: "max_publish_message_size_kb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxPublishRate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxSubscriptionCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxPublishMessageSizeKb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPublishRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxPublishRate, fieldNumber: 1)
    }
    if self.maxSubscriptionCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxSubscriptionCount, fieldNumber: 2)
    }
    if self.maxPublishMessageSizeKb != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxPublishMessageSizeKb, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__TopicLimits, rhs: ControlClient__TopicLimits) -> Bool {
    if lhs.maxPublishRate != rhs.maxPublishRate {return false}
    if lhs.maxSubscriptionCount != rhs.maxSubscriptionCount {return false}
    if lhs.maxPublishMessageSizeKb != rhs.maxPublishMessageSizeKb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__Cache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Cache"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
    2: .standard(proto: "cache_limits"),
    3: .standard(proto: "topic_limits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cacheLimits) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._topicLimits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    try { if let v = self._cacheLimits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._topicLimits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__Cache, rhs: ControlClient__Cache) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs._cacheLimits != rhs._cacheLimits {return false}
    if lhs._topicLimits != rhs._topicLimits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListCachesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListCachesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cache"),
    2: .standard(proto: "next_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cache) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cache.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cache, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListCachesResponse, rhs: ControlClient__ListCachesResponse) -> Bool {
    if lhs.cache != rhs.cache {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateSigningKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateSigningKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ttl_minutes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ttlMinutes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ttlMinutes != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttlMinutes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateSigningKeyRequest, rhs: ControlClient__CreateSigningKeyRequest) -> Bool {
    if lhs.ttlMinutes != rhs.ttlMinutes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__CreateSigningKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._CreateSigningKeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__CreateSigningKeyResponse, rhs: ControlClient__CreateSigningKeyResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__RevokeSigningKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._RevokeSigningKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__RevokeSigningKeyRequest, rhs: ControlClient__RevokeSigningKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__RevokeSigningKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._RevokeSigningKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__RevokeSigningKeyResponse, rhs: ControlClient__RevokeSigningKeyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__SigningKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SigningKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresAt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__SigningKey, rhs: ControlClient__SigningKey) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListSigningKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListSigningKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListSigningKeysRequest, rhs: ControlClient__ListSigningKeysRequest) -> Bool {
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__ListSigningKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListSigningKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signing_key"),
    2: .standard(proto: "next_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signingKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signingKey.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signingKey, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__ListSigningKeysResponse, rhs: ControlClient__ListSigningKeysResponse) -> Bool {
    if lhs.signingKey != rhs.signingKey {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__FlushCacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._FlushCacheRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__FlushCacheRequest, rhs: ControlClient__FlushCacheRequest) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlClient__FlushCacheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._FlushCacheResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ControlClient__FlushCacheResponse, rhs: ControlClient__FlushCacheResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
