// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cacheclient.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum CacheClient_ECacheResult: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalid // = 0
  case ok // = 1
  case hit // = 2
  case miss // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .ok
    case 2: self = .hit
    case 3: self = .miss
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .ok: return 1
    case .hit: return 2
    case .miss: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CacheClient_ECacheResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CacheClient_ECacheResult] = [
    .invalid,
    .ok,
    .hit,
    .miss,
  ]
}

#endif  // swift(>=4.2)

public struct CacheClient__GetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__GetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient_ECacheResult = .invalid

  public var cacheBody: Data = Data()

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var cacheBody: Data = Data()

  public var ttlMilliseconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient_ECacheResult = .invalid

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetIfNotExistsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var cacheBody: Data = Data()

  public var ttlMilliseconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetIfNotExistsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient__SetIfNotExistsResponse.OneOf_Result? = nil

  public var stored: CacheClient__SetIfNotExistsResponse._Stored {
    get {
      if case .stored(let v)? = result {return v}
      return CacheClient__SetIfNotExistsResponse._Stored()
    }
    set {result = .stored(newValue)}
  }

  public var notStored: CacheClient__SetIfNotExistsResponse._NotStored {
    get {
      if case .notStored(let v)? = result {return v}
      return CacheClient__SetIfNotExistsResponse._NotStored()
    }
    set {result = .notStored(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case stored(CacheClient__SetIfNotExistsResponse._Stored)
    case notStored(CacheClient__SetIfNotExistsResponse._NotStored)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetIfNotExistsResponse.OneOf_Result, rhs: CacheClient__SetIfNotExistsResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stored, .stored): return {
        guard case .stored(let l) = lhs, case .stored(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notStored, .notStored): return {
        guard case .notStored(let l) = lhs, case .notStored(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Stored {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _NotStored {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__KeysExistRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__KeysExistResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exists: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__IncrementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  /// Amount to add to the stored value.
  /// If this key doesn't currently exist, it's created with this value (encoded as a base 10 string)
  public var amount: Int64 = 0

  public var ttlMilliseconds: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__IncrementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value stored after the increment operation.
  public var value: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__UpdateTtlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var updateTtl: CacheClient__UpdateTtlRequest.OneOf_UpdateTtl? = nil

  /// Sets the ttl to this value only if it is an increase compared to the existing ttl
  public var increaseToMilliseconds: UInt64 {
    get {
      if case .increaseToMilliseconds(let v)? = updateTtl {return v}
      return 0
    }
    set {updateTtl = .increaseToMilliseconds(newValue)}
  }

  /// Sets the ttl to this value only if it is a decrease compared to the existing ttl
  public var decreaseToMilliseconds: UInt64 {
    get {
      if case .decreaseToMilliseconds(let v)? = updateTtl {return v}
      return 0
    }
    set {updateTtl = .decreaseToMilliseconds(newValue)}
  }

  /// Sets the ttl to this value unconditionally
  public var overwriteToMilliseconds: UInt64 {
    get {
      if case .overwriteToMilliseconds(let v)? = updateTtl {return v}
      return 0
    }
    set {updateTtl = .overwriteToMilliseconds(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UpdateTtl: Equatable {
    /// Sets the ttl to this value only if it is an increase compared to the existing ttl
    case increaseToMilliseconds(UInt64)
    /// Sets the ttl to this value only if it is a decrease compared to the existing ttl
    case decreaseToMilliseconds(UInt64)
    /// Sets the ttl to this value unconditionally
    case overwriteToMilliseconds(UInt64)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__UpdateTtlRequest.OneOf_UpdateTtl, rhs: CacheClient__UpdateTtlRequest.OneOf_UpdateTtl) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.increaseToMilliseconds, .increaseToMilliseconds): return {
        guard case .increaseToMilliseconds(let l) = lhs, case .increaseToMilliseconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decreaseToMilliseconds, .decreaseToMilliseconds): return {
        guard case .decreaseToMilliseconds(let l) = lhs, case .decreaseToMilliseconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.overwriteToMilliseconds, .overwriteToMilliseconds): return {
        guard case .overwriteToMilliseconds(let l) = lhs, case .overwriteToMilliseconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct CacheClient__UpdateTtlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient__UpdateTtlResponse.OneOf_Result? = nil

  public var set: CacheClient__UpdateTtlResponse._Set {
    get {
      if case .set(let v)? = result {return v}
      return CacheClient__UpdateTtlResponse._Set()
    }
    set {result = .set(newValue)}
  }

  public var notSet: CacheClient__UpdateTtlResponse._NotSet {
    get {
      if case .notSet(let v)? = result {return v}
      return CacheClient__UpdateTtlResponse._NotSet()
    }
    set {result = .notSet(newValue)}
  }

  public var missing: CacheClient__UpdateTtlResponse._Missing {
    get {
      if case .missing(let v)? = result {return v}
      return CacheClient__UpdateTtlResponse._Missing()
    }
    set {result = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case set(CacheClient__UpdateTtlResponse._Set)
    case notSet(CacheClient__UpdateTtlResponse._NotSet)
    case missing(CacheClient__UpdateTtlResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__UpdateTtlResponse.OneOf_Result, rhs: CacheClient__UpdateTtlResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notSet, .notSet): return {
        guard case .notSet(let l) = lhs, case .notSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Indicates that the ttl was applied.
  public struct _Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Indicates that the ttl was not applied due to a failed condition.
  public struct _NotSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Indicates that the key did not exist.
  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ItemGetTtlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ItemGetTtlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient__ItemGetTtlResponse.OneOf_Result? = nil

  public var found: CacheClient__ItemGetTtlResponse._Found {
    get {
      if case .found(let v)? = result {return v}
      return CacheClient__ItemGetTtlResponse._Found()
    }
    set {result = .found(newValue)}
  }

  public var missing: CacheClient__ItemGetTtlResponse._Missing {
    get {
      if case .missing(let v)? = result {return v}
      return CacheClient__ItemGetTtlResponse._Missing()
    }
    set {result = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case found(CacheClient__ItemGetTtlResponse._Found)
    case missing(CacheClient__ItemGetTtlResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ItemGetTtlResponse.OneOf_Result, rhs: CacheClient__ItemGetTtlResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var remainingTtlMillis: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ItemGetTypeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cacheKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ItemGetTypeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: CacheClient__ItemGetTypeResponse.OneOf_Result? = nil

  public var found: CacheClient__ItemGetTypeResponse._Found {
    get {
      if case .found(let v)? = result {return v}
      return CacheClient__ItemGetTypeResponse._Found()
    }
    set {result = .found(newValue)}
  }

  public var missing: CacheClient__ItemGetTypeResponse._Missing {
    get {
      if case .missing(let v)? = result {return v}
      return CacheClient__ItemGetTypeResponse._Missing()
    }
    set {result = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case found(CacheClient__ItemGetTypeResponse._Found)
    case missing(CacheClient__ItemGetTypeResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ItemGetTypeResponse.OneOf_Result, rhs: CacheClient__ItemGetTypeResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case scalar // = 0
    case dictionary // = 1
    case set // = 2
    case list // = 3
    case sortedSet // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .scalar
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .scalar
      case 1: self = .dictionary
      case 2: self = .set
      case 3: self = .list
      case 4: self = .sortedSet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .scalar: return 0
      case .dictionary: return 1
      case .set: return 2
      case .list: return 3
      case .sortedSet: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var itemType: CacheClient__ItemGetTypeResponse.ItemType = .scalar

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension CacheClient__ItemGetTypeResponse.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CacheClient__ItemGetTypeResponse.ItemType] = [
    .scalar,
    .dictionary,
    .set,
    .list,
    .sortedSet,
  ]
}

#endif  // swift(>=4.2)

public struct CacheClient__DictionaryGetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var fields: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryGetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionary: CacheClient__DictionaryGetResponse.OneOf_Dictionary? = nil

  public var found: CacheClient__DictionaryGetResponse._Found {
    get {
      if case .found(let v)? = dictionary {return v}
      return CacheClient__DictionaryGetResponse._Found()
    }
    set {dictionary = .found(newValue)}
  }

  public var missing: CacheClient__DictionaryGetResponse._Missing {
    get {
      if case .missing(let v)? = dictionary {return v}
      return CacheClient__DictionaryGetResponse._Missing()
    }
    set {dictionary = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Dictionary: Equatable {
    case found(CacheClient__DictionaryGetResponse._Found)
    case missing(CacheClient__DictionaryGetResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__DictionaryGetResponse.OneOf_Dictionary, rhs: CacheClient__DictionaryGetResponse.OneOf_Dictionary) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _DictionaryGetResponsePart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: CacheClient_ECacheResult = .invalid

    public var cacheBody: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var items: [CacheClient__DictionaryGetResponse._DictionaryGetResponsePart] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__DictionaryFetchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryFieldValuePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: Data = Data()

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryFetchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionary: CacheClient__DictionaryFetchResponse.OneOf_Dictionary? = nil

  public var found: CacheClient__DictionaryFetchResponse._Found {
    get {
      if case .found(let v)? = dictionary {return v}
      return CacheClient__DictionaryFetchResponse._Found()
    }
    set {dictionary = .found(newValue)}
  }

  public var missing: CacheClient__DictionaryFetchResponse._Missing {
    get {
      if case .missing(let v)? = dictionary {return v}
      return CacheClient__DictionaryFetchResponse._Missing()
    }
    set {dictionary = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Dictionary: Equatable {
    case found(CacheClient__DictionaryFetchResponse._Found)
    case missing(CacheClient__DictionaryFetchResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__DictionaryFetchResponse.OneOf_Dictionary, rhs: CacheClient__DictionaryFetchResponse.OneOf_Dictionary) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var items: [CacheClient__DictionaryFieldValuePair] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__DictionarySetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var items: [CacheClient__DictionaryFieldValuePair] = []

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionarySetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryIncrementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var field: Data = Data()

  public var amount: Int64 = 0

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryIncrementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var delete: CacheClient__DictionaryDeleteRequest.OneOf_Delete? = nil

  public var some: CacheClient__DictionaryDeleteRequest.Some {
    get {
      if case .some(let v)? = delete {return v}
      return CacheClient__DictionaryDeleteRequest.Some()
    }
    set {delete = .some(newValue)}
  }

  public var all: CacheClient__DictionaryDeleteRequest.All {
    get {
      if case .all(let v)? = delete {return v}
      return CacheClient__DictionaryDeleteRequest.All()
    }
    set {delete = .all(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Delete: Equatable {
    case some(CacheClient__DictionaryDeleteRequest.Some)
    case all(CacheClient__DictionaryDeleteRequest.All)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__DictionaryDeleteRequest.OneOf_Delete, rhs: CacheClient__DictionaryDeleteRequest.OneOf_Delete) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.some, .some): return {
        guard case .some(let l) = lhs, case .some(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Some {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fields: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct All {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__DictionaryDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryLengthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionaryName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__DictionaryLengthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dictionary: CacheClient__DictionaryLengthResponse.OneOf_Dictionary? = nil

  public var found: CacheClient__DictionaryLengthResponse._Found {
    get {
      if case .found(let v)? = dictionary {return v}
      return CacheClient__DictionaryLengthResponse._Found()
    }
    set {dictionary = .found(newValue)}
  }

  public var missing: CacheClient__DictionaryLengthResponse._Missing {
    get {
      if case .missing(let v)? = dictionary {return v}
      return CacheClient__DictionaryLengthResponse._Missing()
    }
    set {dictionary = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Dictionary: Equatable {
    case found(CacheClient__DictionaryLengthResponse._Found)
    case missing(CacheClient__DictionaryLengthResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__DictionaryLengthResponse.OneOf_Dictionary, rhs: CacheClient__DictionaryLengthResponse.OneOf_Dictionary) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var length: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetFetchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetFetchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: CacheClient__SetFetchResponse.OneOf_Set? = nil

  public var found: CacheClient__SetFetchResponse._Found {
    get {
      if case .found(let v)? = set {return v}
      return CacheClient__SetFetchResponse._Found()
    }
    set {set = .found(newValue)}
  }

  public var missing: CacheClient__SetFetchResponse._Missing {
    get {
      if case .missing(let v)? = set {return v}
      return CacheClient__SetFetchResponse._Missing()
    }
    set {set = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Set: Equatable {
    case found(CacheClient__SetFetchResponse._Found)
    case missing(CacheClient__SetFetchResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetFetchResponse.OneOf_Set, rhs: CacheClient__SetFetchResponse.OneOf_Set) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetUnionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var elements: [Data] = []

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetUnionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetDifferenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var difference: CacheClient__SetDifferenceRequest.OneOf_Difference? = nil

  public var minuend: CacheClient__SetDifferenceRequest._Minuend {
    get {
      if case .minuend(let v)? = difference {return v}
      return CacheClient__SetDifferenceRequest._Minuend()
    }
    set {difference = .minuend(newValue)}
  }

  public var subtrahend: CacheClient__SetDifferenceRequest._Subtrahend {
    get {
      if case .subtrahend(let v)? = difference {return v}
      return CacheClient__SetDifferenceRequest._Subtrahend()
    }
    set {difference = .subtrahend(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Difference: Equatable {
    case minuend(CacheClient__SetDifferenceRequest._Minuend)
    case subtrahend(CacheClient__SetDifferenceRequest._Subtrahend)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetDifferenceRequest.OneOf_Difference, rhs: CacheClient__SetDifferenceRequest.OneOf_Difference) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.minuend, .minuend): return {
        guard case .minuend(let l) = lhs, case .minuend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subtrahend, .subtrahend): return {
        guard case .subtrahend(let l) = lhs, case .subtrahend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// cache = request - stored
  public struct _Minuend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// cache = stored - request
  public struct _Subtrahend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subtrahendSet: CacheClient__SetDifferenceRequest._Subtrahend.OneOf_SubtrahendSet? = nil

    public var set: CacheClient__SetDifferenceRequest._Subtrahend._Set {
      get {
        if case .set(let v)? = subtrahendSet {return v}
        return CacheClient__SetDifferenceRequest._Subtrahend._Set()
      }
      set {subtrahendSet = .set(newValue)}
    }

    public var identity: CacheClient__SetDifferenceRequest._Subtrahend._Identity {
      get {
        if case .identity(let v)? = subtrahendSet {return v}
        return CacheClient__SetDifferenceRequest._Subtrahend._Identity()
      }
      set {subtrahendSet = .identity(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_SubtrahendSet: Equatable {
      case set(CacheClient__SetDifferenceRequest._Subtrahend._Set)
      case identity(CacheClient__SetDifferenceRequest._Subtrahend._Identity)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SetDifferenceRequest._Subtrahend.OneOf_SubtrahendSet, rhs: CacheClient__SetDifferenceRequest._Subtrahend.OneOf_SubtrahendSet) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.set, .set): return {
          guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.identity, .identity): return {
          guard case .identity(let l) = lhs, case .identity(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Subtract a set of elements
    public struct _Set {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var elements: [Data] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Subtract the set's identity (itself) from itself - which deletes it.
    public struct _Identity {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetDifferenceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: CacheClient__SetDifferenceResponse.OneOf_Set? = nil

  public var found: CacheClient__SetDifferenceResponse._Found {
    get {
      if case .found(let v)? = set {return v}
      return CacheClient__SetDifferenceResponse._Found()
    }
    set {set = .found(newValue)}
  }

  public var missing: CacheClient__SetDifferenceResponse._Missing {
    get {
      if case .missing(let v)? = set {return v}
      return CacheClient__SetDifferenceResponse._Missing()
    }
    set {set = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Set: Equatable {
    case found(CacheClient__SetDifferenceResponse._Found)
    case missing(CacheClient__SetDifferenceResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetDifferenceResponse.OneOf_Set, rhs: CacheClient__SetDifferenceResponse.OneOf_Set) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetContainsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var elements: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetContainsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: CacheClient__SetContainsResponse.OneOf_Set? = nil

  public var found: CacheClient__SetContainsResponse._Found {
    get {
      if case .found(let v)? = set {return v}
      return CacheClient__SetContainsResponse._Found()
    }
    set {set = .found(newValue)}
  }

  public var missing: CacheClient__SetContainsResponse._Missing {
    get {
      if case .missing(let v)? = set {return v}
      return CacheClient__SetContainsResponse._Missing()
    }
    set {set = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Set: Equatable {
    case found(CacheClient__SetContainsResponse._Found)
    case missing(CacheClient__SetContainsResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetContainsResponse.OneOf_Set, rhs: CacheClient__SetContainsResponse.OneOf_Set) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This will be the same length as the elements passed in the request.
    /// It represents whether each element is a member of the set, with indices corresponding to the request elements.
    public var contains: [Bool] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetLengthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetLengthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: CacheClient__SetLengthResponse.OneOf_Set? = nil

  public var found: CacheClient__SetLengthResponse._Found {
    get {
      if case .found(let v)? = set {return v}
      return CacheClient__SetLengthResponse._Found()
    }
    set {set = .found(newValue)}
  }

  public var missing: CacheClient__SetLengthResponse._Missing {
    get {
      if case .missing(let v)? = set {return v}
      return CacheClient__SetLengthResponse._Missing()
    }
    set {set = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Set: Equatable {
    case found(CacheClient__SetLengthResponse._Found)
    case missing(CacheClient__SetLengthResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetLengthResponse.OneOf_Set, rhs: CacheClient__SetLengthResponse.OneOf_Set) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var length: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SetPopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SetPopResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var set: CacheClient__SetPopResponse.OneOf_Set? = nil

  public var found: CacheClient__SetPopResponse._Found {
    get {
      if case .found(let v)? = set {return v}
      return CacheClient__SetPopResponse._Found()
    }
    set {set = .found(newValue)}
  }

  public var missing: CacheClient__SetPopResponse._Missing {
    get {
      if case .missing(let v)? = set {return v}
      return CacheClient__SetPopResponse._Missing()
    }
    set {set = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Set: Equatable {
    case found(CacheClient__SetPopResponse._Found)
    case missing(CacheClient__SetPopResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SetPopResponse.OneOf_Set, rhs: CacheClient__SetPopResponse.OneOf_Set) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListConcatenateFrontRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var values: [Data] = []

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  /// ensure total length <= this; remove excess from back of list
  public var truncateBackToSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListConcatenateFrontResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// length of the list after the concatenation
  public var listLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListConcatenateBackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var values: [Data] = []

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  /// ensure total length <= this; remove excess from front of list
  public var truncateFrontToSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListConcatenateBackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// length of the list after the concatenation
  public var listLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// stored = request + stored
public struct CacheClient__ListPushFrontRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var value: Data = Data()

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  /// ensure total length <= this; remove excess from back of list
  public var truncateBackToSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListPushFrontResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// length of the list after the push
  public var listLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// stored = stored + request
public struct CacheClient__ListPushBackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var value: Data = Data()

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  /// ensure total length <= this; remove excess from front of list
  public var truncateFrontToSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListPushBackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// length of the list after the push
  public var listLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListPopFrontRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListPopFrontResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListPopFrontResponse.OneOf_List? = nil

  public var found: CacheClient__ListPopFrontResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListPopFrontResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListPopFrontResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListPopFrontResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListPopFrontResponse._Found)
    case missing(CacheClient__ListPopFrontResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListPopFrontResponse.OneOf_List, rhs: CacheClient__ListPopFrontResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var front: Data = Data()

    /// length of the list after the pop
    public var listLength: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListPopBackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListPopBackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListPopBackResponse.OneOf_List? = nil

  public var found: CacheClient__ListPopBackResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListPopBackResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListPopBackResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListPopBackResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListPopBackResponse._Found)
    case missing(CacheClient__ListPopBackResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListPopBackResponse.OneOf_List, rhs: CacheClient__ListPopBackResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var back: Data = Data()

    /// length of the list after the pop
    public var listLength: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginIndex: UInt32 = 0

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListEraseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var erase: CacheClient__ListEraseRequest.OneOf_Erase? = nil

  public var some: CacheClient__ListEraseRequest._ListRanges {
    get {
      if case .some(let v)? = erase {return v}
      return CacheClient__ListEraseRequest._ListRanges()
    }
    set {erase = .some(newValue)}
  }

  public var all: CacheClient__ListEraseRequest._All {
    get {
      if case .all(let v)? = erase {return v}
      return CacheClient__ListEraseRequest._All()
    }
    set {erase = .all(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Erase: Equatable {
    case some(CacheClient__ListEraseRequest._ListRanges)
    case all(CacheClient__ListEraseRequest._All)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListEraseRequest.OneOf_Erase, rhs: CacheClient__ListEraseRequest.OneOf_Erase) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.some, .some): return {
        guard case .some(let l) = lhs, case .some(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _All {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _ListRanges {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ranges: [CacheClient__ListRange] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListEraseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListEraseResponse.OneOf_List? = nil

  public var found: CacheClient__ListEraseResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListEraseResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListEraseResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListEraseResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListEraseResponse._Found)
    case missing(CacheClient__ListEraseResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListEraseResponse.OneOf_List, rhs: CacheClient__ListEraseResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var listLength: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListRemoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var remove: CacheClient__ListRemoveRequest.OneOf_Remove? = nil

  /// Remove all appearances in the list where the element is this value
  public var allElementsWithValue: Data {
    get {
      if case .allElementsWithValue(let v)? = remove {return v}
      return Data()
    }
    set {remove = .allElementsWithValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Remove: Equatable {
    /// Remove all appearances in the list where the element is this value
    case allElementsWithValue(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListRemoveRequest.OneOf_Remove, rhs: CacheClient__ListRemoveRequest.OneOf_Remove) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.allElementsWithValue, .allElementsWithValue): return {
        guard case .allElementsWithValue(let l) = lhs, case .allElementsWithValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct CacheClient__ListRemoveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListRemoveResponse.OneOf_List? = nil

  public var found: CacheClient__ListRemoveResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListRemoveResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListRemoveResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListRemoveResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListRemoveResponse._Found)
    case missing(CacheClient__ListRemoveResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListRemoveResponse.OneOf_List, rhs: CacheClient__ListRemoveResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var listLength: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__Unbounded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListFetchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  /// Inclusive.
  /// If unbounded, 0 (start of list) by default
  /// A negative index counts from the end of the list
  public var startIndex: CacheClient__ListFetchRequest.OneOf_StartIndex? = nil

  public var unboundedStart: CacheClient__Unbounded {
    get {
      if case .unboundedStart(let v)? = startIndex {return v}
      return CacheClient__Unbounded()
    }
    set {startIndex = .unboundedStart(newValue)}
  }

  public var inclusiveStart: Int32 {
    get {
      if case .inclusiveStart(let v)? = startIndex {return v}
      return 0
    }
    set {startIndex = .inclusiveStart(newValue)}
  }

  /// Exclusive.
  /// If unbounded, this effectively means list.length()
  /// If end_index is > the number of elements to return, return as much as you can
  /// A negative index counts from the end of the list
  public var endIndex: CacheClient__ListFetchRequest.OneOf_EndIndex? = nil

  public var unboundedEnd: CacheClient__Unbounded {
    get {
      if case .unboundedEnd(let v)? = endIndex {return v}
      return CacheClient__Unbounded()
    }
    set {endIndex = .unboundedEnd(newValue)}
  }

  public var exclusiveEnd: Int32 {
    get {
      if case .exclusiveEnd(let v)? = endIndex {return v}
      return 0
    }
    set {endIndex = .exclusiveEnd(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Inclusive.
  /// If unbounded, 0 (start of list) by default
  /// A negative index counts from the end of the list
  public enum OneOf_StartIndex: Equatable {
    case unboundedStart(CacheClient__Unbounded)
    case inclusiveStart(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListFetchRequest.OneOf_StartIndex, rhs: CacheClient__ListFetchRequest.OneOf_StartIndex) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unboundedStart, .unboundedStart): return {
        guard case .unboundedStart(let l) = lhs, case .unboundedStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inclusiveStart, .inclusiveStart): return {
        guard case .inclusiveStart(let l) = lhs, case .inclusiveStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Exclusive.
  /// If unbounded, this effectively means list.length()
  /// If end_index is > the number of elements to return, return as much as you can
  /// A negative index counts from the end of the list
  public enum OneOf_EndIndex: Equatable {
    case unboundedEnd(CacheClient__Unbounded)
    case exclusiveEnd(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListFetchRequest.OneOf_EndIndex, rhs: CacheClient__ListFetchRequest.OneOf_EndIndex) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unboundedEnd, .unboundedEnd): return {
        guard case .unboundedEnd(let l) = lhs, case .unboundedEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exclusiveEnd, .exclusiveEnd): return {
        guard case .exclusiveEnd(let l) = lhs, case .exclusiveEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct CacheClient__ListRetainRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var startIndex: CacheClient__ListRetainRequest.OneOf_StartIndex? = nil

  public var unboundedStart: CacheClient__Unbounded {
    get {
      if case .unboundedStart(let v)? = startIndex {return v}
      return CacheClient__Unbounded()
    }
    set {startIndex = .unboundedStart(newValue)}
  }

  public var inclusiveStart: Int32 {
    get {
      if case .inclusiveStart(let v)? = startIndex {return v}
      return 0
    }
    set {startIndex = .inclusiveStart(newValue)}
  }

  public var endIndex: CacheClient__ListRetainRequest.OneOf_EndIndex? = nil

  public var unboundedEnd: CacheClient__Unbounded {
    get {
      if case .unboundedEnd(let v)? = endIndex {return v}
      return CacheClient__Unbounded()
    }
    set {endIndex = .unboundedEnd(newValue)}
  }

  public var exclusiveEnd: Int32 {
    get {
      if case .exclusiveEnd(let v)? = endIndex {return v}
      return 0
    }
    set {endIndex = .exclusiveEnd(newValue)}
  }

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StartIndex: Equatable {
    case unboundedStart(CacheClient__Unbounded)
    case inclusiveStart(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListRetainRequest.OneOf_StartIndex, rhs: CacheClient__ListRetainRequest.OneOf_StartIndex) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unboundedStart, .unboundedStart): return {
        guard case .unboundedStart(let l) = lhs, case .unboundedStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inclusiveStart, .inclusiveStart): return {
        guard case .inclusiveStart(let l) = lhs, case .inclusiveStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_EndIndex: Equatable {
    case unboundedEnd(CacheClient__Unbounded)
    case exclusiveEnd(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListRetainRequest.OneOf_EndIndex, rhs: CacheClient__ListRetainRequest.OneOf_EndIndex) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unboundedEnd, .unboundedEnd): return {
        guard case .unboundedEnd(let l) = lhs, case .unboundedEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exclusiveEnd, .exclusiveEnd): return {
        guard case .exclusiveEnd(let l) = lhs, case .exclusiveEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct CacheClient__ListRetainResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListRetainResponse.OneOf_List? = nil

  public var found: CacheClient__ListRetainResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListRetainResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListRetainResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListRetainResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListRetainResponse._Found)
    case missing(CacheClient__ListRetainResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListRetainResponse.OneOf_List, rhs: CacheClient__ListRetainResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var listLength: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListFetchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListFetchResponse.OneOf_List? = nil

  public var found: CacheClient__ListFetchResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListFetchResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListFetchResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListFetchResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListFetchResponse._Found)
    case missing(CacheClient__ListFetchResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListFetchResponse.OneOf_List, rhs: CacheClient__ListFetchResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__ListLengthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__ListLengthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var list: CacheClient__ListLengthResponse.OneOf_List? = nil

  public var found: CacheClient__ListLengthResponse._Found {
    get {
      if case .found(let v)? = list {return v}
      return CacheClient__ListLengthResponse._Found()
    }
    set {list = .found(newValue)}
  }

  public var missing: CacheClient__ListLengthResponse._Missing {
    get {
      if case .missing(let v)? = list {return v}
      return CacheClient__ListLengthResponse._Missing()
    }
    set {list = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_List: Equatable {
    case found(CacheClient__ListLengthResponse._Found)
    case missing(CacheClient__ListLengthResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__ListLengthResponse.OneOf_List, rhs: CacheClient__ListLengthResponse.OneOf_List) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var length: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var score: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetPutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var elements: [CacheClient__SortedSetElement] = []

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetPutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetFetchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var order: CacheClient__SortedSetFetchRequest.Order = .ascending

  public var withScores: Bool = false

  public var range: CacheClient__SortedSetFetchRequest.OneOf_Range? = nil

  public var byIndex: CacheClient__SortedSetFetchRequest._ByIndex {
    get {
      if case .byIndex(let v)? = range {return v}
      return CacheClient__SortedSetFetchRequest._ByIndex()
    }
    set {range = .byIndex(newValue)}
  }

  public var byScore: CacheClient__SortedSetFetchRequest._ByScore {
    get {
      if case .byScore(let v)? = range {return v}
      return CacheClient__SortedSetFetchRequest._ByScore()
    }
    set {range = .byScore(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Range: Equatable {
    case byIndex(CacheClient__SortedSetFetchRequest._ByIndex)
    case byScore(CacheClient__SortedSetFetchRequest._ByScore)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetFetchRequest.OneOf_Range, rhs: CacheClient__SortedSetFetchRequest.OneOf_Range) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.byIndex, .byIndex): return {
        guard case .byIndex(let l) = lhs, case .byIndex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byScore, .byScore): return {
        guard case .byScore(let l) = lhs, case .byScore(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Order: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ascending // = 0
    case descending // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ascending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ascending
      case 1: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ascending: return 0
      case .descending: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Start and end are zero-based indexes, with 0 being the first element.
  /// A negative index indicates offsets from the end of the sorted set, with
  /// -1 being the last element.
  public struct _ByIndex {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Start is inclusive.
    /// Unbounded is treated as 0.
    public var start: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_Start? = nil

    public var unboundedStart: CacheClient__Unbounded {
      get {
        if case .unboundedStart(let v)? = start {return v}
        return CacheClient__Unbounded()
      }
      set {start = .unboundedStart(newValue)}
    }

    public var inclusiveStartIndex: Int32 {
      get {
        if case .inclusiveStartIndex(let v)? = start {return v}
        return 0
      }
      set {start = .inclusiveStartIndex(newValue)}
    }

    /// End is exclusive.
    /// Unbounded is treated as the number of elements in the sorted set.
    public var end: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_End? = nil

    public var unboundedEnd: CacheClient__Unbounded {
      get {
        if case .unboundedEnd(let v)? = end {return v}
        return CacheClient__Unbounded()
      }
      set {end = .unboundedEnd(newValue)}
    }

    public var exclusiveEndIndex: Int32 {
      get {
        if case .exclusiveEndIndex(let v)? = end {return v}
        return 0
      }
      set {end = .exclusiveEndIndex(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Start is inclusive.
    /// Unbounded is treated as 0.
    public enum OneOf_Start: Equatable {
      case unboundedStart(CacheClient__Unbounded)
      case inclusiveStartIndex(Int32)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_Start, rhs: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_Start) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.unboundedStart, .unboundedStart): return {
          guard case .unboundedStart(let l) = lhs, case .unboundedStart(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.inclusiveStartIndex, .inclusiveStartIndex): return {
          guard case .inclusiveStartIndex(let l) = lhs, case .inclusiveStartIndex(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// End is exclusive.
    /// Unbounded is treated as the number of elements in the sorted set.
    public enum OneOf_End: Equatable {
      case unboundedEnd(CacheClient__Unbounded)
      case exclusiveEndIndex(Int32)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_End, rhs: CacheClient__SortedSetFetchRequest._ByIndex.OneOf_End) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.unboundedEnd, .unboundedEnd): return {
          guard case .unboundedEnd(let l) = lhs, case .unboundedEnd(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.exclusiveEndIndex, .exclusiveEndIndex): return {
          guard case .exclusiveEndIndex(let l) = lhs, case .exclusiveEndIndex(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct _ByScore {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var min: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Min? = nil

    public var unboundedMin: CacheClient__Unbounded {
      get {
        if case .unboundedMin(let v)? = min {return v}
        return CacheClient__Unbounded()
      }
      set {min = .unboundedMin(newValue)}
    }

    public var minScore: CacheClient__SortedSetFetchRequest._ByScore._Score {
      get {
        if case .minScore(let v)? = min {return v}
        return CacheClient__SortedSetFetchRequest._ByScore._Score()
      }
      set {min = .minScore(newValue)}
    }

    public var max: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Max? = nil

    public var unboundedMax: CacheClient__Unbounded {
      get {
        if case .unboundedMax(let v)? = max {return v}
        return CacheClient__Unbounded()
      }
      set {max = .unboundedMax(newValue)}
    }

    public var maxScore: CacheClient__SortedSetFetchRequest._ByScore._Score {
      get {
        if case .maxScore(let v)? = max {return v}
        return CacheClient__SortedSetFetchRequest._ByScore._Score()
      }
      set {max = .maxScore(newValue)}
    }

    /// Offset and count are used to only get a range of the matching elements,
    /// similar to "SELECT LIMIT offset, count" in SQL.
    /// A negative count returns all elements from the offset.
    /// Use (0, -1) to return all matching elements.
    public var offset: UInt32 = 0

    public var count: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Min: Equatable {
      case unboundedMin(CacheClient__Unbounded)
      case minScore(CacheClient__SortedSetFetchRequest._ByScore._Score)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Min, rhs: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Min) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.unboundedMin, .unboundedMin): return {
          guard case .unboundedMin(let l) = lhs, case .unboundedMin(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.minScore, .minScore): return {
          guard case .minScore(let l) = lhs, case .minScore(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_Max: Equatable {
      case unboundedMax(CacheClient__Unbounded)
      case maxScore(CacheClient__SortedSetFetchRequest._ByScore._Score)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Max, rhs: CacheClient__SortedSetFetchRequest._ByScore.OneOf_Max) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.unboundedMax, .unboundedMax): return {
          guard case .unboundedMax(let l) = lhs, case .unboundedMax(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.maxScore, .maxScore): return {
          guard case .maxScore(let l) = lhs, case .maxScore(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct _Score {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var score: Double = 0

      public var exclusive: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension CacheClient__SortedSetFetchRequest.Order: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CacheClient__SortedSetFetchRequest.Order] = [
    .ascending,
    .descending,
  ]
}

#endif  // swift(>=4.2)

public struct CacheClient__SortedSetFetchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortedSet: CacheClient__SortedSetFetchResponse.OneOf_SortedSet? = nil

  public var found: CacheClient__SortedSetFetchResponse._Found {
    get {
      if case .found(let v)? = sortedSet {return v}
      return CacheClient__SortedSetFetchResponse._Found()
    }
    set {sortedSet = .found(newValue)}
  }

  public var missing: CacheClient__SortedSetFetchResponse._Missing {
    get {
      if case .missing(let v)? = sortedSet {return v}
      return CacheClient__SortedSetFetchResponse._Missing()
    }
    set {sortedSet = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortedSet: Equatable {
    case found(CacheClient__SortedSetFetchResponse._Found)
    case missing(CacheClient__SortedSetFetchResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetFetchResponse.OneOf_SortedSet, rhs: CacheClient__SortedSetFetchResponse.OneOf_SortedSet) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: CacheClient__SortedSetFetchResponse._Found.OneOf_Elements? = nil

    public var valuesWithScores: CacheClient__SortedSetFetchResponse._Found._ValuesWithScores {
      get {
        if case .valuesWithScores(let v)? = elements {return v}
        return CacheClient__SortedSetFetchResponse._Found._ValuesWithScores()
      }
      set {elements = .valuesWithScores(newValue)}
    }

    public var values: CacheClient__SortedSetFetchResponse._Found._Values {
      get {
        if case .values(let v)? = elements {return v}
        return CacheClient__SortedSetFetchResponse._Found._Values()
      }
      set {elements = .values(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Elements: Equatable {
      case valuesWithScores(CacheClient__SortedSetFetchResponse._Found._ValuesWithScores)
      case values(CacheClient__SortedSetFetchResponse._Found._Values)

    #if !swift(>=4.1)
      public static func ==(lhs: CacheClient__SortedSetFetchResponse._Found.OneOf_Elements, rhs: CacheClient__SortedSetFetchResponse._Found.OneOf_Elements) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.valuesWithScores, .valuesWithScores): return {
          guard case .valuesWithScores(let l) = lhs, case .valuesWithScores(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.values, .values): return {
          guard case .values(let l) = lhs, case .values(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct _ValuesWithScores {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var elements: [CacheClient__SortedSetElement] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct _Values {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var values: [Data] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetGetScoreRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var values: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetGetScoreResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortedSet: CacheClient__SortedSetGetScoreResponse.OneOf_SortedSet? = nil

  public var found: CacheClient__SortedSetGetScoreResponse._SortedSetFound {
    get {
      if case .found(let v)? = sortedSet {return v}
      return CacheClient__SortedSetGetScoreResponse._SortedSetFound()
    }
    set {sortedSet = .found(newValue)}
  }

  public var missing: CacheClient__SortedSetGetScoreResponse._SortedSetMissing {
    get {
      if case .missing(let v)? = sortedSet {return v}
      return CacheClient__SortedSetGetScoreResponse._SortedSetMissing()
    }
    set {sortedSet = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortedSet: Equatable {
    case found(CacheClient__SortedSetGetScoreResponse._SortedSetFound)
    case missing(CacheClient__SortedSetGetScoreResponse._SortedSetMissing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetGetScoreResponse.OneOf_SortedSet, rhs: CacheClient__SortedSetGetScoreResponse.OneOf_SortedSet) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _SortedSetGetScoreResponsePart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: CacheClient_ECacheResult = .invalid

    public var score: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _SortedSetFound {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var elements: [CacheClient__SortedSetGetScoreResponse._SortedSetGetScoreResponsePart] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _SortedSetMissing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetRemoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var removeElements: CacheClient__SortedSetRemoveRequest.OneOf_RemoveElements? = nil

  public var all: CacheClient__SortedSetRemoveRequest._All {
    get {
      if case .all(let v)? = removeElements {return v}
      return CacheClient__SortedSetRemoveRequest._All()
    }
    set {removeElements = .all(newValue)}
  }

  public var some: CacheClient__SortedSetRemoveRequest._Some {
    get {
      if case .some(let v)? = removeElements {return v}
      return CacheClient__SortedSetRemoveRequest._Some()
    }
    set {removeElements = .some(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RemoveElements: Equatable {
    case all(CacheClient__SortedSetRemoveRequest._All)
    case some(CacheClient__SortedSetRemoveRequest._Some)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetRemoveRequest.OneOf_RemoveElements, rhs: CacheClient__SortedSetRemoveRequest.OneOf_RemoveElements) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.some, .some): return {
        guard case .some(let l) = lhs, case .some(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _All {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Some {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetRemoveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetIncrementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var value: Data = Data()

  public var amount: Double = 0

  public var ttlMilliseconds: UInt64 = 0

  public var refreshTtl: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetIncrementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated score stored after the increment operation.
  public var score: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetGetRankRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var value: Data = Data()

  /// The order in which sorted set will be sorted to determine the rank.
  ///
  /// When Order.ASCENDING is specified, will return the rank of the value
  /// when sorted set scores are ordered from low to high. This is the default
  /// when no Order is specified.
  ///
  /// When Order.DESCENDING is specified, will return the rank of the value
  /// when sorted set scores are ordered from high to low.
  public var order: CacheClient__SortedSetGetRankRequest.Order = .ascending

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Order: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ascending // = 0
    case descending // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ascending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ascending
      case 1: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ascending: return 0
      case .descending: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension CacheClient__SortedSetGetRankRequest.Order: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [CacheClient__SortedSetGetRankRequest.Order] = [
    .ascending,
    .descending,
  ]
}

#endif  // swift(>=4.2)

public struct CacheClient__SortedSetGetRankResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rank: CacheClient__SortedSetGetRankResponse.OneOf_Rank? = nil

  public var elementRank: CacheClient__SortedSetGetRankResponse._RankResponsePart {
    get {
      if case .elementRank(let v)? = rank {return v}
      return CacheClient__SortedSetGetRankResponse._RankResponsePart()
    }
    set {rank = .elementRank(newValue)}
  }

  public var missing: CacheClient__SortedSetGetRankResponse._SortedSetMissing {
    get {
      if case .missing(let v)? = rank {return v}
      return CacheClient__SortedSetGetRankResponse._SortedSetMissing()
    }
    set {rank = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rank: Equatable {
    case elementRank(CacheClient__SortedSetGetRankResponse._RankResponsePart)
    case missing(CacheClient__SortedSetGetRankResponse._SortedSetMissing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetGetRankResponse.OneOf_Rank, rhs: CacheClient__SortedSetGetRankResponse.OneOf_Rank) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.elementRank, .elementRank): return {
        guard case .elementRank(let l) = lhs, case .elementRank(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _RankResponsePart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var result: CacheClient_ECacheResult = .invalid

    /// Rank is 0-based i.e. when sort order is descending the rank of the
    /// value with the highest score will be 0. Similarly for ascending order,
    /// value with the lowest score will have rank 0.
    public var rank: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _SortedSetMissing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetLengthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CacheClient__SortedSetLengthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortedSet: CacheClient__SortedSetLengthResponse.OneOf_SortedSet? = nil

  public var found: CacheClient__SortedSetLengthResponse._Found {
    get {
      if case .found(let v)? = sortedSet {return v}
      return CacheClient__SortedSetLengthResponse._Found()
    }
    set {sortedSet = .found(newValue)}
  }

  public var missing: CacheClient__SortedSetLengthResponse._Missing {
    get {
      if case .missing(let v)? = sortedSet {return v}
      return CacheClient__SortedSetLengthResponse._Missing()
    }
    set {sortedSet = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortedSet: Equatable {
    case found(CacheClient__SortedSetLengthResponse._Found)
    case missing(CacheClient__SortedSetLengthResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetLengthResponse.OneOf_SortedSet, rhs: CacheClient__SortedSetLengthResponse.OneOf_SortedSet) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var length: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct CacheClient__SortedSetLengthByScoreRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var setName: Data = Data()

  public var min: CacheClient__SortedSetLengthByScoreRequest.OneOf_Min? = nil

  public var inclusiveMin: Double {
    get {
      if case .inclusiveMin(let v)? = min {return v}
      return 0
    }
    set {min = .inclusiveMin(newValue)}
  }

  public var exclusiveMin: Double {
    get {
      if case .exclusiveMin(let v)? = min {return v}
      return 0
    }
    set {min = .exclusiveMin(newValue)}
  }

  public var unboundedMin: CacheClient__Unbounded {
    get {
      if case .unboundedMin(let v)? = min {return v}
      return CacheClient__Unbounded()
    }
    set {min = .unboundedMin(newValue)}
  }

  public var max: CacheClient__SortedSetLengthByScoreRequest.OneOf_Max? = nil

  public var inclusiveMax: Double {
    get {
      if case .inclusiveMax(let v)? = max {return v}
      return 0
    }
    set {max = .inclusiveMax(newValue)}
  }

  public var exclusiveMax: Double {
    get {
      if case .exclusiveMax(let v)? = max {return v}
      return 0
    }
    set {max = .exclusiveMax(newValue)}
  }

  public var unboundedMax: CacheClient__Unbounded {
    get {
      if case .unboundedMax(let v)? = max {return v}
      return CacheClient__Unbounded()
    }
    set {max = .unboundedMax(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Min: Equatable {
    case inclusiveMin(Double)
    case exclusiveMin(Double)
    case unboundedMin(CacheClient__Unbounded)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetLengthByScoreRequest.OneOf_Min, rhs: CacheClient__SortedSetLengthByScoreRequest.OneOf_Min) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inclusiveMin, .inclusiveMin): return {
        guard case .inclusiveMin(let l) = lhs, case .inclusiveMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exclusiveMin, .exclusiveMin): return {
        guard case .exclusiveMin(let l) = lhs, case .exclusiveMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unboundedMin, .unboundedMin): return {
        guard case .unboundedMin(let l) = lhs, case .unboundedMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_Max: Equatable {
    case inclusiveMax(Double)
    case exclusiveMax(Double)
    case unboundedMax(CacheClient__Unbounded)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetLengthByScoreRequest.OneOf_Max, rhs: CacheClient__SortedSetLengthByScoreRequest.OneOf_Max) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inclusiveMax, .inclusiveMax): return {
        guard case .inclusiveMax(let l) = lhs, case .inclusiveMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exclusiveMax, .exclusiveMax): return {
        guard case .exclusiveMax(let l) = lhs, case .exclusiveMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unboundedMax, .unboundedMax): return {
        guard case .unboundedMax(let l) = lhs, case .unboundedMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct CacheClient__SortedSetLengthByScoreResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortedSet: CacheClient__SortedSetLengthByScoreResponse.OneOf_SortedSet? = nil

  public var found: CacheClient__SortedSetLengthByScoreResponse._Found {
    get {
      if case .found(let v)? = sortedSet {return v}
      return CacheClient__SortedSetLengthByScoreResponse._Found()
    }
    set {sortedSet = .found(newValue)}
  }

  public var missing: CacheClient__SortedSetLengthByScoreResponse._Missing {
    get {
      if case .missing(let v)? = sortedSet {return v}
      return CacheClient__SortedSetLengthByScoreResponse._Missing()
    }
    set {sortedSet = .missing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SortedSet: Equatable {
    case found(CacheClient__SortedSetLengthByScoreResponse._Found)
    case missing(CacheClient__SortedSetLengthByScoreResponse._Missing)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient__SortedSetLengthByScoreResponse.OneOf_SortedSet, rhs: CacheClient__SortedSetLengthByScoreResponse.OneOf_SortedSet) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct _Found {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var length: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct _Missing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CacheClient_ECacheResult: @unchecked Sendable {}
extension CacheClient__GetRequest: @unchecked Sendable {}
extension CacheClient__GetResponse: @unchecked Sendable {}
extension CacheClient__DeleteRequest: @unchecked Sendable {}
extension CacheClient__DeleteResponse: @unchecked Sendable {}
extension CacheClient__SetRequest: @unchecked Sendable {}
extension CacheClient__SetResponse: @unchecked Sendable {}
extension CacheClient__SetIfNotExistsRequest: @unchecked Sendable {}
extension CacheClient__SetIfNotExistsResponse: @unchecked Sendable {}
extension CacheClient__SetIfNotExistsResponse.OneOf_Result: @unchecked Sendable {}
extension CacheClient__SetIfNotExistsResponse._Stored: @unchecked Sendable {}
extension CacheClient__SetIfNotExistsResponse._NotStored: @unchecked Sendable {}
extension CacheClient__KeysExistRequest: @unchecked Sendable {}
extension CacheClient__KeysExistResponse: @unchecked Sendable {}
extension CacheClient__IncrementRequest: @unchecked Sendable {}
extension CacheClient__IncrementResponse: @unchecked Sendable {}
extension CacheClient__UpdateTtlRequest: @unchecked Sendable {}
extension CacheClient__UpdateTtlRequest.OneOf_UpdateTtl: @unchecked Sendable {}
extension CacheClient__UpdateTtlResponse: @unchecked Sendable {}
extension CacheClient__UpdateTtlResponse.OneOf_Result: @unchecked Sendable {}
extension CacheClient__UpdateTtlResponse._Set: @unchecked Sendable {}
extension CacheClient__UpdateTtlResponse._NotSet: @unchecked Sendable {}
extension CacheClient__UpdateTtlResponse._Missing: @unchecked Sendable {}
extension CacheClient__ItemGetTtlRequest: @unchecked Sendable {}
extension CacheClient__ItemGetTtlResponse: @unchecked Sendable {}
extension CacheClient__ItemGetTtlResponse.OneOf_Result: @unchecked Sendable {}
extension CacheClient__ItemGetTtlResponse._Found: @unchecked Sendable {}
extension CacheClient__ItemGetTtlResponse._Missing: @unchecked Sendable {}
extension CacheClient__ItemGetTypeRequest: @unchecked Sendable {}
extension CacheClient__ItemGetTypeResponse: @unchecked Sendable {}
extension CacheClient__ItemGetTypeResponse.OneOf_Result: @unchecked Sendable {}
extension CacheClient__ItemGetTypeResponse.ItemType: @unchecked Sendable {}
extension CacheClient__ItemGetTypeResponse._Found: @unchecked Sendable {}
extension CacheClient__ItemGetTypeResponse._Missing: @unchecked Sendable {}
extension CacheClient__DictionaryGetRequest: @unchecked Sendable {}
extension CacheClient__DictionaryGetResponse: @unchecked Sendable {}
extension CacheClient__DictionaryGetResponse.OneOf_Dictionary: @unchecked Sendable {}
extension CacheClient__DictionaryGetResponse._DictionaryGetResponsePart: @unchecked Sendable {}
extension CacheClient__DictionaryGetResponse._Found: @unchecked Sendable {}
extension CacheClient__DictionaryGetResponse._Missing: @unchecked Sendable {}
extension CacheClient__DictionaryFetchRequest: @unchecked Sendable {}
extension CacheClient__DictionaryFieldValuePair: @unchecked Sendable {}
extension CacheClient__DictionaryFetchResponse: @unchecked Sendable {}
extension CacheClient__DictionaryFetchResponse.OneOf_Dictionary: @unchecked Sendable {}
extension CacheClient__DictionaryFetchResponse._Found: @unchecked Sendable {}
extension CacheClient__DictionaryFetchResponse._Missing: @unchecked Sendable {}
extension CacheClient__DictionarySetRequest: @unchecked Sendable {}
extension CacheClient__DictionarySetResponse: @unchecked Sendable {}
extension CacheClient__DictionaryIncrementRequest: @unchecked Sendable {}
extension CacheClient__DictionaryIncrementResponse: @unchecked Sendable {}
extension CacheClient__DictionaryDeleteRequest: @unchecked Sendable {}
extension CacheClient__DictionaryDeleteRequest.OneOf_Delete: @unchecked Sendable {}
extension CacheClient__DictionaryDeleteRequest.Some: @unchecked Sendable {}
extension CacheClient__DictionaryDeleteRequest.All: @unchecked Sendable {}
extension CacheClient__DictionaryDeleteResponse: @unchecked Sendable {}
extension CacheClient__DictionaryLengthRequest: @unchecked Sendable {}
extension CacheClient__DictionaryLengthResponse: @unchecked Sendable {}
extension CacheClient__DictionaryLengthResponse.OneOf_Dictionary: @unchecked Sendable {}
extension CacheClient__DictionaryLengthResponse._Found: @unchecked Sendable {}
extension CacheClient__DictionaryLengthResponse._Missing: @unchecked Sendable {}
extension CacheClient__SetFetchRequest: @unchecked Sendable {}
extension CacheClient__SetFetchResponse: @unchecked Sendable {}
extension CacheClient__SetFetchResponse.OneOf_Set: @unchecked Sendable {}
extension CacheClient__SetFetchResponse._Found: @unchecked Sendable {}
extension CacheClient__SetFetchResponse._Missing: @unchecked Sendable {}
extension CacheClient__SetUnionRequest: @unchecked Sendable {}
extension CacheClient__SetUnionResponse: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest.OneOf_Difference: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest._Minuend: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest._Subtrahend: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest._Subtrahend.OneOf_SubtrahendSet: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest._Subtrahend._Set: @unchecked Sendable {}
extension CacheClient__SetDifferenceRequest._Subtrahend._Identity: @unchecked Sendable {}
extension CacheClient__SetDifferenceResponse: @unchecked Sendable {}
extension CacheClient__SetDifferenceResponse.OneOf_Set: @unchecked Sendable {}
extension CacheClient__SetDifferenceResponse._Found: @unchecked Sendable {}
extension CacheClient__SetDifferenceResponse._Missing: @unchecked Sendable {}
extension CacheClient__SetContainsRequest: @unchecked Sendable {}
extension CacheClient__SetContainsResponse: @unchecked Sendable {}
extension CacheClient__SetContainsResponse.OneOf_Set: @unchecked Sendable {}
extension CacheClient__SetContainsResponse._Found: @unchecked Sendable {}
extension CacheClient__SetContainsResponse._Missing: @unchecked Sendable {}
extension CacheClient__SetLengthRequest: @unchecked Sendable {}
extension CacheClient__SetLengthResponse: @unchecked Sendable {}
extension CacheClient__SetLengthResponse.OneOf_Set: @unchecked Sendable {}
extension CacheClient__SetLengthResponse._Found: @unchecked Sendable {}
extension CacheClient__SetLengthResponse._Missing: @unchecked Sendable {}
extension CacheClient__SetPopRequest: @unchecked Sendable {}
extension CacheClient__SetPopResponse: @unchecked Sendable {}
extension CacheClient__SetPopResponse.OneOf_Set: @unchecked Sendable {}
extension CacheClient__SetPopResponse._Found: @unchecked Sendable {}
extension CacheClient__SetPopResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListConcatenateFrontRequest: @unchecked Sendable {}
extension CacheClient__ListConcatenateFrontResponse: @unchecked Sendable {}
extension CacheClient__ListConcatenateBackRequest: @unchecked Sendable {}
extension CacheClient__ListConcatenateBackResponse: @unchecked Sendable {}
extension CacheClient__ListPushFrontRequest: @unchecked Sendable {}
extension CacheClient__ListPushFrontResponse: @unchecked Sendable {}
extension CacheClient__ListPushBackRequest: @unchecked Sendable {}
extension CacheClient__ListPushBackResponse: @unchecked Sendable {}
extension CacheClient__ListPopFrontRequest: @unchecked Sendable {}
extension CacheClient__ListPopFrontResponse: @unchecked Sendable {}
extension CacheClient__ListPopFrontResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListPopFrontResponse._Found: @unchecked Sendable {}
extension CacheClient__ListPopFrontResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListPopBackRequest: @unchecked Sendable {}
extension CacheClient__ListPopBackResponse: @unchecked Sendable {}
extension CacheClient__ListPopBackResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListPopBackResponse._Found: @unchecked Sendable {}
extension CacheClient__ListPopBackResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListRange: @unchecked Sendable {}
extension CacheClient__ListEraseRequest: @unchecked Sendable {}
extension CacheClient__ListEraseRequest.OneOf_Erase: @unchecked Sendable {}
extension CacheClient__ListEraseRequest._All: @unchecked Sendable {}
extension CacheClient__ListEraseRequest._ListRanges: @unchecked Sendable {}
extension CacheClient__ListEraseResponse: @unchecked Sendable {}
extension CacheClient__ListEraseResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListEraseResponse._Found: @unchecked Sendable {}
extension CacheClient__ListEraseResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListRemoveRequest: @unchecked Sendable {}
extension CacheClient__ListRemoveRequest.OneOf_Remove: @unchecked Sendable {}
extension CacheClient__ListRemoveResponse: @unchecked Sendable {}
extension CacheClient__ListRemoveResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListRemoveResponse._Found: @unchecked Sendable {}
extension CacheClient__ListRemoveResponse._Missing: @unchecked Sendable {}
extension CacheClient__Unbounded: @unchecked Sendable {}
extension CacheClient__ListFetchRequest: @unchecked Sendable {}
extension CacheClient__ListFetchRequest.OneOf_StartIndex: @unchecked Sendable {}
extension CacheClient__ListFetchRequest.OneOf_EndIndex: @unchecked Sendable {}
extension CacheClient__ListRetainRequest: @unchecked Sendable {}
extension CacheClient__ListRetainRequest.OneOf_StartIndex: @unchecked Sendable {}
extension CacheClient__ListRetainRequest.OneOf_EndIndex: @unchecked Sendable {}
extension CacheClient__ListRetainResponse: @unchecked Sendable {}
extension CacheClient__ListRetainResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListRetainResponse._Found: @unchecked Sendable {}
extension CacheClient__ListRetainResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListFetchResponse: @unchecked Sendable {}
extension CacheClient__ListFetchResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListFetchResponse._Found: @unchecked Sendable {}
extension CacheClient__ListFetchResponse._Missing: @unchecked Sendable {}
extension CacheClient__ListLengthRequest: @unchecked Sendable {}
extension CacheClient__ListLengthResponse: @unchecked Sendable {}
extension CacheClient__ListLengthResponse.OneOf_List: @unchecked Sendable {}
extension CacheClient__ListLengthResponse._Found: @unchecked Sendable {}
extension CacheClient__ListLengthResponse._Missing: @unchecked Sendable {}
extension CacheClient__SortedSetElement: @unchecked Sendable {}
extension CacheClient__SortedSetPutRequest: @unchecked Sendable {}
extension CacheClient__SortedSetPutResponse: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest.OneOf_Range: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest.Order: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByIndex: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByIndex.OneOf_Start: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByIndex.OneOf_End: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByScore: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByScore.OneOf_Min: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByScore.OneOf_Max: @unchecked Sendable {}
extension CacheClient__SortedSetFetchRequest._ByScore._Score: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse.OneOf_SortedSet: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse._Found: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse._Found.OneOf_Elements: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse._Found._ValuesWithScores: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse._Found._Values: @unchecked Sendable {}
extension CacheClient__SortedSetFetchResponse._Missing: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreRequest: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreResponse: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreResponse.OneOf_SortedSet: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreResponse._SortedSetGetScoreResponsePart: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreResponse._SortedSetFound: @unchecked Sendable {}
extension CacheClient__SortedSetGetScoreResponse._SortedSetMissing: @unchecked Sendable {}
extension CacheClient__SortedSetRemoveRequest: @unchecked Sendable {}
extension CacheClient__SortedSetRemoveRequest.OneOf_RemoveElements: @unchecked Sendable {}
extension CacheClient__SortedSetRemoveRequest._All: @unchecked Sendable {}
extension CacheClient__SortedSetRemoveRequest._Some: @unchecked Sendable {}
extension CacheClient__SortedSetRemoveResponse: @unchecked Sendable {}
extension CacheClient__SortedSetIncrementRequest: @unchecked Sendable {}
extension CacheClient__SortedSetIncrementResponse: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankRequest: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankRequest.Order: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankResponse: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankResponse.OneOf_Rank: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankResponse._RankResponsePart: @unchecked Sendable {}
extension CacheClient__SortedSetGetRankResponse._SortedSetMissing: @unchecked Sendable {}
extension CacheClient__SortedSetLengthRequest: @unchecked Sendable {}
extension CacheClient__SortedSetLengthResponse: @unchecked Sendable {}
extension CacheClient__SortedSetLengthResponse.OneOf_SortedSet: @unchecked Sendable {}
extension CacheClient__SortedSetLengthResponse._Found: @unchecked Sendable {}
extension CacheClient__SortedSetLengthResponse._Missing: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreRequest: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreRequest.OneOf_Min: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreRequest.OneOf_Max: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreResponse: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreResponse.OneOf_SortedSet: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreResponse._Found: @unchecked Sendable {}
extension CacheClient__SortedSetLengthByScoreResponse._Missing: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cache_client"

extension CacheClient_ECacheResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Invalid"),
    1: .same(proto: "Ok"),
    2: .same(proto: "Hit"),
    3: .same(proto: "Miss"),
  ]
}

extension CacheClient__GetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._GetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__GetRequest, rhs: CacheClient__GetRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__GetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._GetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "cache_body"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cacheBody) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .invalid {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.cacheBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheBody, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__GetResponse, rhs: CacheClient__GetResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.cacheBody != rhs.cacheBody {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DeleteRequest, rhs: CacheClient__DeleteRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DeleteResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DeleteResponse, rhs: CacheClient__DeleteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
    2: .standard(proto: "cache_body"),
    3: .standard(proto: "ttl_milliseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cacheBody) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    if !self.cacheBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheBody, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetRequest, rhs: CacheClient__SetRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.cacheBody != rhs.cacheBody {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .invalid {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetResponse, rhs: CacheClient__SetResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetIfNotExistsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetIfNotExistsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
    2: .standard(proto: "cache_body"),
    3: .standard(proto: "ttl_milliseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cacheBody) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    if !self.cacheBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheBody, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetIfNotExistsRequest, rhs: CacheClient__SetIfNotExistsRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.cacheBody != rhs.cacheBody {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetIfNotExistsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetIfNotExistsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stored"),
    2: .standard(proto: "not_stored"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetIfNotExistsResponse._Stored?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .stored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .stored(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetIfNotExistsResponse._NotStored?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .notStored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .notStored(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .stored?: try {
      guard case .stored(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .notStored?: try {
      guard case .notStored(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetIfNotExistsResponse, rhs: CacheClient__SetIfNotExistsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetIfNotExistsResponse._Stored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetIfNotExistsResponse.protoMessageName + "._Stored"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetIfNotExistsResponse._Stored, rhs: CacheClient__SetIfNotExistsResponse._Stored) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetIfNotExistsResponse._NotStored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetIfNotExistsResponse.protoMessageName + "._NotStored"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetIfNotExistsResponse._NotStored, rhs: CacheClient__SetIfNotExistsResponse._NotStored) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__KeysExistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._KeysExistRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.cacheKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.cacheKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__KeysExistRequest, rhs: CacheClient__KeysExistRequest) -> Bool {
    if lhs.cacheKeys != rhs.cacheKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__KeysExistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._KeysExistResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.exists) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exists.isEmpty {
      try visitor.visitPackedBoolField(value: self.exists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__KeysExistResponse, rhs: CacheClient__KeysExistResponse) -> Bool {
    if lhs.exists != rhs.exists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__IncrementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._IncrementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
    2: .same(proto: "amount"),
    3: .standard(proto: "ttl_milliseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__IncrementRequest, rhs: CacheClient__IncrementRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__IncrementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._IncrementResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__IncrementResponse, rhs: CacheClient__IncrementResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__UpdateTtlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._UpdateTtlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
    2: .standard(proto: "increase_to_milliseconds"),
    3: .standard(proto: "decrease_to_milliseconds"),
    4: .standard(proto: "overwrite_to_milliseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.updateTtl != nil {try decoder.handleConflictingOneOf()}
          self.updateTtl = .increaseToMilliseconds(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.updateTtl != nil {try decoder.handleConflictingOneOf()}
          self.updateTtl = .decreaseToMilliseconds(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.updateTtl != nil {try decoder.handleConflictingOneOf()}
          self.updateTtl = .overwriteToMilliseconds(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    switch self.updateTtl {
    case .increaseToMilliseconds?: try {
      guard case .increaseToMilliseconds(let v)? = self.updateTtl else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .decreaseToMilliseconds?: try {
      guard case .decreaseToMilliseconds(let v)? = self.updateTtl else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case .overwriteToMilliseconds?: try {
      guard case .overwriteToMilliseconds(let v)? = self.updateTtl else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__UpdateTtlRequest, rhs: CacheClient__UpdateTtlRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.updateTtl != rhs.updateTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__UpdateTtlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._UpdateTtlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .standard(proto: "not_set"),
    3: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__UpdateTtlResponse._Set?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .set(v)
        }
      }()
      case 2: try {
        var v: CacheClient__UpdateTtlResponse._NotSet?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .notSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .notSet(v)
        }
      }()
      case 3: try {
        var v: CacheClient__UpdateTtlResponse._Missing?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .set?: try {
      guard case .set(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .notSet?: try {
      guard case .notSet(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__UpdateTtlResponse, rhs: CacheClient__UpdateTtlResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__UpdateTtlResponse._Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__UpdateTtlResponse.protoMessageName + "._Set"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__UpdateTtlResponse._Set, rhs: CacheClient__UpdateTtlResponse._Set) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__UpdateTtlResponse._NotSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__UpdateTtlResponse.protoMessageName + "._NotSet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__UpdateTtlResponse._NotSet, rhs: CacheClient__UpdateTtlResponse._NotSet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__UpdateTtlResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__UpdateTtlResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__UpdateTtlResponse._Missing, rhs: CacheClient__UpdateTtlResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTtlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ItemGetTtlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTtlRequest, rhs: CacheClient__ItemGetTtlRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTtlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ItemGetTtlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ItemGetTtlResponse._Found?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ItemGetTtlResponse._Missing?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .found?: try {
      guard case .found(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTtlResponse, rhs: CacheClient__ItemGetTtlResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTtlResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ItemGetTtlResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remaining_ttl_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.remainingTtlMillis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.remainingTtlMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.remainingTtlMillis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTtlResponse._Found, rhs: CacheClient__ItemGetTtlResponse._Found) -> Bool {
    if lhs.remainingTtlMillis != rhs.remainingTtlMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTtlResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ItemGetTtlResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTtlResponse._Missing, rhs: CacheClient__ItemGetTtlResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ItemGetTypeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cacheKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTypeRequest, rhs: CacheClient__ItemGetTypeRequest) -> Bool {
    if lhs.cacheKey != rhs.cacheKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ItemGetTypeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ItemGetTypeResponse._Found?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ItemGetTypeResponse._Missing?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .found?: try {
      guard case .found(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTypeResponse, rhs: CacheClient__ItemGetTypeResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTypeResponse.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCALAR"),
    1: .same(proto: "DICTIONARY"),
    2: .same(proto: "SET"),
    3: .same(proto: "LIST"),
    4: .same(proto: "SORTED_SET"),
  ]
}

extension CacheClient__ItemGetTypeResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ItemGetTypeResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemType != .scalar {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTypeResponse._Found, rhs: CacheClient__ItemGetTypeResponse._Found) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ItemGetTypeResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ItemGetTypeResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ItemGetTypeResponse._Missing, rhs: CacheClient__ItemGetTypeResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryGetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryGetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryGetRequest, rhs: CacheClient__DictionaryGetRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryGetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryGetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__DictionaryGetResponse._Found?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__DictionaryGetResponse._Missing?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.dictionary {
    case .found?: try {
      guard case .found(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryGetResponse, rhs: CacheClient__DictionaryGetResponse) -> Bool {
    if lhs.dictionary != rhs.dictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryGetResponse._DictionaryGetResponsePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryGetResponse.protoMessageName + "._DictionaryGetResponsePart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "cache_body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cacheBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .invalid {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.cacheBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.cacheBody, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryGetResponse._DictionaryGetResponsePart, rhs: CacheClient__DictionaryGetResponse._DictionaryGetResponsePart) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.cacheBody != rhs.cacheBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryGetResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryGetResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryGetResponse._Found, rhs: CacheClient__DictionaryGetResponse._Found) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryGetResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryGetResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryGetResponse._Missing, rhs: CacheClient__DictionaryGetResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryFetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryFetchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryFetchRequest, rhs: CacheClient__DictionaryFetchRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryFieldValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryFieldValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularBytesField(value: self.field, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryFieldValuePair, rhs: CacheClient__DictionaryFieldValuePair) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryFetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryFetchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__DictionaryFetchResponse._Found?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__DictionaryFetchResponse._Missing?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.dictionary {
    case .found?: try {
      guard case .found(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryFetchResponse, rhs: CacheClient__DictionaryFetchResponse) -> Bool {
    if lhs.dictionary != rhs.dictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryFetchResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryFetchResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryFetchResponse._Found, rhs: CacheClient__DictionaryFetchResponse._Found) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryFetchResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryFetchResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryFetchResponse._Missing, rhs: CacheClient__DictionaryFetchResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionarySetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionarySetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
    2: .same(proto: "items"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionarySetRequest, rhs: CacheClient__DictionarySetRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.items != rhs.items {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionarySetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionarySetResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionarySetResponse, rhs: CacheClient__DictionarySetResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryIncrementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryIncrementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
    2: .same(proto: "field"),
    3: .same(proto: "amount"),
    4: .standard(proto: "ttl_milliseconds"),
    5: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.field) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    if !self.field.isEmpty {
      try visitor.visitSingularBytesField(value: self.field, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 4)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryIncrementRequest, rhs: CacheClient__DictionaryIncrementRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.field != rhs.field {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryIncrementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryIncrementResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryIncrementResponse, rhs: CacheClient__DictionaryIncrementResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryDeleteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
    2: .same(proto: "some"),
    3: .same(proto: "all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      case 2: try {
        var v: CacheClient__DictionaryDeleteRequest.Some?
        var hadOneofValue = false
        if let current = self.delete {
          hadOneofValue = true
          if case .some(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.delete = .some(v)
        }
      }()
      case 3: try {
        var v: CacheClient__DictionaryDeleteRequest.All?
        var hadOneofValue = false
        if let current = self.delete {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.delete = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    switch self.delete {
    case .some?: try {
      guard case .some(let v)? = self.delete else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .all?: try {
      guard case .all(let v)? = self.delete else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryDeleteRequest, rhs: CacheClient__DictionaryDeleteRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.delete != rhs.delete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryDeleteRequest.Some: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryDeleteRequest.protoMessageName + ".Some"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryDeleteRequest.Some, rhs: CacheClient__DictionaryDeleteRequest.Some) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryDeleteRequest.All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryDeleteRequest.protoMessageName + ".All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryDeleteRequest.All, rhs: CacheClient__DictionaryDeleteRequest.All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryDeleteResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryDeleteResponse, rhs: CacheClient__DictionaryDeleteResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryLengthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryLengthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dictionary_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dictionaryName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dictionaryName.isEmpty {
      try visitor.visitSingularBytesField(value: self.dictionaryName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryLengthRequest, rhs: CacheClient__DictionaryLengthRequest) -> Bool {
    if lhs.dictionaryName != rhs.dictionaryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryLengthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._DictionaryLengthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__DictionaryLengthResponse._Found?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__DictionaryLengthResponse._Missing?
        var hadOneofValue = false
        if let current = self.dictionary {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.dictionary = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.dictionary {
    case .found?: try {
      guard case .found(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.dictionary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryLengthResponse, rhs: CacheClient__DictionaryLengthResponse) -> Bool {
    if lhs.dictionary != rhs.dictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryLengthResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryLengthResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryLengthResponse._Found, rhs: CacheClient__DictionaryLengthResponse._Found) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__DictionaryLengthResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__DictionaryLengthResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__DictionaryLengthResponse._Missing, rhs: CacheClient__DictionaryLengthResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetFetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetFetchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetFetchRequest, rhs: CacheClient__SetFetchRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetFetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetFetchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetFetchResponse._Found?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetFetchResponse._Missing?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.set {
    case .found?: try {
      guard case .found(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetFetchResponse, rhs: CacheClient__SetFetchResponse) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetFetchResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetFetchResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetFetchResponse._Found, rhs: CacheClient__SetFetchResponse._Found) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetFetchResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetFetchResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetFetchResponse._Missing, rhs: CacheClient__SetFetchResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetUnionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetUnionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "elements"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetUnionRequest, rhs: CacheClient__SetUnionRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetUnionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetUnionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetUnionResponse, rhs: CacheClient__SetUnionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetDifferenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "minuend"),
    3: .same(proto: "subtrahend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try {
        var v: CacheClient__SetDifferenceRequest._Minuend?
        var hadOneofValue = false
        if let current = self.difference {
          hadOneofValue = true
          if case .minuend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.difference = .minuend(v)
        }
      }()
      case 3: try {
        var v: CacheClient__SetDifferenceRequest._Subtrahend?
        var hadOneofValue = false
        if let current = self.difference {
          hadOneofValue = true
          if case .subtrahend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.difference = .subtrahend(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    switch self.difference {
    case .minuend?: try {
      guard case .minuend(let v)? = self.difference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subtrahend?: try {
      guard case .subtrahend(let v)? = self.difference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceRequest, rhs: CacheClient__SetDifferenceRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.difference != rhs.difference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceRequest._Minuend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceRequest.protoMessageName + "._Minuend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceRequest._Minuend, rhs: CacheClient__SetDifferenceRequest._Minuend) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceRequest._Subtrahend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceRequest.protoMessageName + "._Subtrahend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetDifferenceRequest._Subtrahend._Set?
        var hadOneofValue = false
        if let current = self.subtrahendSet {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subtrahendSet = .set(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetDifferenceRequest._Subtrahend._Identity?
        var hadOneofValue = false
        if let current = self.subtrahendSet {
          hadOneofValue = true
          if case .identity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subtrahendSet = .identity(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subtrahendSet {
    case .set?: try {
      guard case .set(let v)? = self.subtrahendSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .identity?: try {
      guard case .identity(let v)? = self.subtrahendSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceRequest._Subtrahend, rhs: CacheClient__SetDifferenceRequest._Subtrahend) -> Bool {
    if lhs.subtrahendSet != rhs.subtrahendSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceRequest._Subtrahend._Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceRequest._Subtrahend.protoMessageName + "._Set"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceRequest._Subtrahend._Set, rhs: CacheClient__SetDifferenceRequest._Subtrahend._Set) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceRequest._Subtrahend._Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceRequest._Subtrahend.protoMessageName + "._Identity"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceRequest._Subtrahend._Identity, rhs: CacheClient__SetDifferenceRequest._Subtrahend._Identity) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetDifferenceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetDifferenceResponse._Found?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetDifferenceResponse._Missing?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.set {
    case .found?: try {
      guard case .found(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceResponse, rhs: CacheClient__SetDifferenceResponse) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceResponse._Found, rhs: CacheClient__SetDifferenceResponse._Found) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetDifferenceResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetDifferenceResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetDifferenceResponse._Missing, rhs: CacheClient__SetDifferenceResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetContainsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetContainsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetContainsRequest, rhs: CacheClient__SetContainsRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetContainsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetContainsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetContainsResponse._Found?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetContainsResponse._Missing?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.set {
    case .found?: try {
      guard case .found(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetContainsResponse, rhs: CacheClient__SetContainsResponse) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetContainsResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetContainsResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contains"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.contains) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contains.isEmpty {
      try visitor.visitPackedBoolField(value: self.contains, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetContainsResponse._Found, rhs: CacheClient__SetContainsResponse._Found) -> Bool {
    if lhs.contains != rhs.contains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetContainsResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetContainsResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetContainsResponse._Missing, rhs: CacheClient__SetContainsResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetLengthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetLengthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetLengthRequest, rhs: CacheClient__SetLengthRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetLengthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetLengthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetLengthResponse._Found?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetLengthResponse._Missing?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.set {
    case .found?: try {
      guard case .found(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetLengthResponse, rhs: CacheClient__SetLengthResponse) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetLengthResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetLengthResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetLengthResponse._Found, rhs: CacheClient__SetLengthResponse._Found) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetLengthResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetLengthResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetLengthResponse._Missing, rhs: CacheClient__SetLengthResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetPopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetPopRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetPopRequest, rhs: CacheClient__SetPopRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetPopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SetPopResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SetPopResponse._Found?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SetPopResponse._Missing?
        var hadOneofValue = false
        if let current = self.set {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.set = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.set {
    case .found?: try {
      guard case .found(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.set else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetPopResponse, rhs: CacheClient__SetPopResponse) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetPopResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetPopResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetPopResponse._Found, rhs: CacheClient__SetPopResponse._Found) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SetPopResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SetPopResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SetPopResponse._Missing, rhs: CacheClient__SetPopResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListConcatenateFrontRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListConcatenateFrontRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .same(proto: "values"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
    5: .standard(proto: "truncate_back_to_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.truncateBackToSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    if self.truncateBackToSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.truncateBackToSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListConcatenateFrontRequest, rhs: CacheClient__ListConcatenateFrontRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.values != rhs.values {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.truncateBackToSize != rhs.truncateBackToSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListConcatenateFrontResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListConcatenateFrontResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListConcatenateFrontResponse, rhs: CacheClient__ListConcatenateFrontResponse) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListConcatenateBackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListConcatenateBackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .same(proto: "values"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
    5: .standard(proto: "truncate_front_to_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.truncateFrontToSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    if self.truncateFrontToSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.truncateFrontToSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListConcatenateBackRequest, rhs: CacheClient__ListConcatenateBackRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.values != rhs.values {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.truncateFrontToSize != rhs.truncateFrontToSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListConcatenateBackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListConcatenateBackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListConcatenateBackResponse, rhs: CacheClient__ListConcatenateBackResponse) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPushFrontRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPushFrontRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .same(proto: "value"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
    5: .standard(proto: "truncate_back_to_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.truncateBackToSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    if self.truncateBackToSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.truncateBackToSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPushFrontRequest, rhs: CacheClient__ListPushFrontRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.truncateBackToSize != rhs.truncateBackToSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPushFrontResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPushFrontResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPushFrontResponse, rhs: CacheClient__ListPushFrontResponse) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPushBackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPushBackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .same(proto: "value"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
    5: .standard(proto: "truncate_front_to_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.truncateFrontToSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    if self.truncateFrontToSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.truncateFrontToSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPushBackRequest, rhs: CacheClient__ListPushBackRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.truncateFrontToSize != rhs.truncateFrontToSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPushBackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPushBackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPushBackResponse, rhs: CacheClient__ListPushBackResponse) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopFrontRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPopFrontRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopFrontRequest, rhs: CacheClient__ListPopFrontRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopFrontResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPopFrontResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListPopFrontResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListPopFrontResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopFrontResponse, rhs: CacheClient__ListPopFrontResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopFrontResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListPopFrontResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "front"),
    2: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.front) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.front.isEmpty {
      try visitor.visitSingularBytesField(value: self.front, fieldNumber: 1)
    }
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopFrontResponse._Found, rhs: CacheClient__ListPopFrontResponse._Found) -> Bool {
    if lhs.front != rhs.front {return false}
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopFrontResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListPopFrontResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopFrontResponse._Missing, rhs: CacheClient__ListPopFrontResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopBackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPopBackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopBackRequest, rhs: CacheClient__ListPopBackRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopBackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListPopBackResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListPopBackResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListPopBackResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopBackResponse, rhs: CacheClient__ListPopBackResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopBackResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListPopBackResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "back"),
    2: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.back) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.back.isEmpty {
      try visitor.visitSingularBytesField(value: self.back, fieldNumber: 1)
    }
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopBackResponse._Found, rhs: CacheClient__ListPopBackResponse._Found) -> Bool {
    if lhs.back != rhs.back {return false}
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListPopBackResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListPopBackResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListPopBackResponse._Missing, rhs: CacheClient__ListPopBackResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "begin_index"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.beginIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.beginIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.beginIndex, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRange, rhs: CacheClient__ListRange) -> Bool {
    if lhs.beginIndex != rhs.beginIndex {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListEraseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .same(proto: "some"),
    3: .same(proto: "all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try {
        var v: CacheClient__ListEraseRequest._ListRanges?
        var hadOneofValue = false
        if let current = self.erase {
          hadOneofValue = true
          if case .some(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.erase = .some(v)
        }
      }()
      case 3: try {
        var v: CacheClient__ListEraseRequest._All?
        var hadOneofValue = false
        if let current = self.erase {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.erase = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    switch self.erase {
    case .some?: try {
      guard case .some(let v)? = self.erase else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .all?: try {
      guard case .all(let v)? = self.erase else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseRequest, rhs: CacheClient__ListEraseRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.erase != rhs.erase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseRequest._All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListEraseRequest.protoMessageName + "._All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseRequest._All, rhs: CacheClient__ListEraseRequest._All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseRequest._ListRanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListEraseRequest.protoMessageName + "._ListRanges"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ranges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseRequest._ListRanges, rhs: CacheClient__ListEraseRequest._ListRanges) -> Bool {
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListEraseResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListEraseResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListEraseResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseResponse, rhs: CacheClient__ListEraseResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListEraseResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseResponse._Found, rhs: CacheClient__ListEraseResponse._Found) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListEraseResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListEraseResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListEraseResponse._Missing, rhs: CacheClient__ListEraseResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRemoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListRemoveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .standard(proto: "all_elements_with_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.remove != nil {try decoder.handleConflictingOneOf()}
          self.remove = .allElementsWithValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    try { if case .allElementsWithValue(let v)? = self.remove {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRemoveRequest, rhs: CacheClient__ListRemoveRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.remove != rhs.remove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRemoveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListRemoveResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListRemoveResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListRemoveResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRemoveResponse, rhs: CacheClient__ListRemoveResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRemoveResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListRemoveResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRemoveResponse._Found, rhs: CacheClient__ListRemoveResponse._Found) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRemoveResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListRemoveResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRemoveResponse._Missing, rhs: CacheClient__ListRemoveResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__Unbounded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Unbounded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__Unbounded, rhs: CacheClient__Unbounded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListFetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListFetchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .standard(proto: "unbounded_start"),
    3: .standard(proto: "inclusive_start"),
    4: .standard(proto: "unbounded_end"),
    5: .standard(proto: "exclusive_end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.startIndex {
          hadOneofValue = true
          if case .unboundedStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.startIndex = .unboundedStart(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.startIndex != nil {try decoder.handleConflictingOneOf()}
          self.startIndex = .inclusiveStart(v)
        }
      }()
      case 4: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.endIndex {
          hadOneofValue = true
          if case .unboundedEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.endIndex = .unboundedEnd(v)
        }
      }()
      case 5: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.endIndex != nil {try decoder.handleConflictingOneOf()}
          self.endIndex = .exclusiveEnd(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    switch self.startIndex {
    case .unboundedStart?: try {
      guard case .unboundedStart(let v)? = self.startIndex else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .inclusiveStart?: try {
      guard case .inclusiveStart(let v)? = self.startIndex else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.endIndex {
    case .unboundedEnd?: try {
      guard case .unboundedEnd(let v)? = self.endIndex else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .exclusiveEnd?: try {
      guard case .exclusiveEnd(let v)? = self.endIndex else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListFetchRequest, rhs: CacheClient__ListFetchRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRetainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListRetainRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
    2: .standard(proto: "unbounded_start"),
    3: .standard(proto: "inclusive_start"),
    4: .standard(proto: "unbounded_end"),
    5: .standard(proto: "exclusive_end"),
    6: .standard(proto: "ttl_milliseconds"),
    7: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      case 2: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.startIndex {
          hadOneofValue = true
          if case .unboundedStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.startIndex = .unboundedStart(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.startIndex != nil {try decoder.handleConflictingOneOf()}
          self.startIndex = .inclusiveStart(v)
        }
      }()
      case 4: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.endIndex {
          hadOneofValue = true
          if case .unboundedEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.endIndex = .unboundedEnd(v)
        }
      }()
      case 5: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.endIndex != nil {try decoder.handleConflictingOneOf()}
          self.endIndex = .exclusiveEnd(v)
        }
      }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    switch self.startIndex {
    case .unboundedStart?: try {
      guard case .unboundedStart(let v)? = self.startIndex else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .inclusiveStart?: try {
      guard case .inclusiveStart(let v)? = self.startIndex else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.endIndex {
    case .unboundedEnd?: try {
      guard case .unboundedEnd(let v)? = self.endIndex else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .exclusiveEnd?: try {
      guard case .exclusiveEnd(let v)? = self.endIndex else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 6)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRetainRequest, rhs: CacheClient__ListRetainRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.endIndex != rhs.endIndex {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRetainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListRetainResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListRetainResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListRetainResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRetainResponse, rhs: CacheClient__ListRetainResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRetainResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListRetainResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.listLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.listLength, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRetainResponse._Found, rhs: CacheClient__ListRetainResponse._Found) -> Bool {
    if lhs.listLength != rhs.listLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListRetainResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListRetainResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListRetainResponse._Missing, rhs: CacheClient__ListRetainResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListFetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListFetchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListFetchResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListFetchResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListFetchResponse, rhs: CacheClient__ListFetchResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListFetchResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListFetchResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListFetchResponse._Found, rhs: CacheClient__ListFetchResponse._Found) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListFetchResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListFetchResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListFetchResponse._Missing, rhs: CacheClient__ListFetchResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListLengthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListLengthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.listName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listName.isEmpty {
      try visitor.visitSingularBytesField(value: self.listName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListLengthRequest, rhs: CacheClient__ListLengthRequest) -> Bool {
    if lhs.listName != rhs.listName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListLengthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._ListLengthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__ListLengthResponse._Found?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__ListLengthResponse._Missing?
        var hadOneofValue = false
        if let current = self.list {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.list = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.list {
    case .found?: try {
      guard case .found(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.list else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListLengthResponse, rhs: CacheClient__ListLengthResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListLengthResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListLengthResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListLengthResponse._Found, rhs: CacheClient__ListLengthResponse._Found) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__ListLengthResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__ListLengthResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__ListLengthResponse._Missing, rhs: CacheClient__ListLengthResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    if self.score != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetElement, rhs: CacheClient__SortedSetElement) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetPutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetPutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "elements"),
    3: .standard(proto: "ttl_milliseconds"),
    4: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 3)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetPutRequest, rhs: CacheClient__SortedSetPutRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetPutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetPutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetPutResponse, rhs: CacheClient__SortedSetPutResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetFetchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "order"),
    3: .standard(proto: "with_scores"),
    4: .standard(proto: "by_index"),
    5: .standard(proto: "by_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.order) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.withScores) }()
      case 4: try {
        var v: CacheClient__SortedSetFetchRequest._ByIndex?
        var hadOneofValue = false
        if let current = self.range {
          hadOneofValue = true
          if case .byIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.range = .byIndex(v)
        }
      }()
      case 5: try {
        var v: CacheClient__SortedSetFetchRequest._ByScore?
        var hadOneofValue = false
        if let current = self.range {
          hadOneofValue = true
          if case .byScore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.range = .byScore(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if self.order != .ascending {
      try visitor.visitSingularEnumField(value: self.order, fieldNumber: 2)
    }
    if self.withScores != false {
      try visitor.visitSingularBoolField(value: self.withScores, fieldNumber: 3)
    }
    switch self.range {
    case .byIndex?: try {
      guard case .byIndex(let v)? = self.range else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .byScore?: try {
      guard case .byScore(let v)? = self.range else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchRequest, rhs: CacheClient__SortedSetFetchRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.order != rhs.order {return false}
    if lhs.withScores != rhs.withScores {return false}
    if lhs.range != rhs.range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchRequest.Order: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASCENDING"),
    1: .same(proto: "DESCENDING"),
  ]
}

extension CacheClient__SortedSetFetchRequest._ByIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchRequest.protoMessageName + "._ByIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbounded_start"),
    2: .standard(proto: "inclusive_start_index"),
    3: .standard(proto: "unbounded_end"),
    4: .standard(proto: "exclusive_end_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.start {
          hadOneofValue = true
          if case .unboundedStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.start = .unboundedStart(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.start != nil {try decoder.handleConflictingOneOf()}
          self.start = .inclusiveStartIndex(v)
        }
      }()
      case 3: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.end {
          hadOneofValue = true
          if case .unboundedEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.end = .unboundedEnd(v)
        }
      }()
      case 4: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.end != nil {try decoder.handleConflictingOneOf()}
          self.end = .exclusiveEndIndex(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.start {
    case .unboundedStart?: try {
      guard case .unboundedStart(let v)? = self.start else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .inclusiveStartIndex?: try {
      guard case .inclusiveStartIndex(let v)? = self.start else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.end {
    case .unboundedEnd?: try {
      guard case .unboundedEnd(let v)? = self.end else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .exclusiveEndIndex?: try {
      guard case .exclusiveEndIndex(let v)? = self.end else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByIndex, rhs: CacheClient__SortedSetFetchRequest._ByIndex) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchRequest._ByScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchRequest.protoMessageName + "._ByScore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbounded_min"),
    2: .standard(proto: "min_score"),
    3: .standard(proto: "unbounded_max"),
    4: .standard(proto: "max_score"),
    5: .same(proto: "offset"),
    6: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.min {
          hadOneofValue = true
          if case .unboundedMin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.min = .unboundedMin(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetFetchRequest._ByScore._Score?
        var hadOneofValue = false
        if let current = self.min {
          hadOneofValue = true
          if case .minScore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.min = .minScore(v)
        }
      }()
      case 3: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.max {
          hadOneofValue = true
          if case .unboundedMax(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.max = .unboundedMax(v)
        }
      }()
      case 4: try {
        var v: CacheClient__SortedSetFetchRequest._ByScore._Score?
        var hadOneofValue = false
        if let current = self.max {
          hadOneofValue = true
          if case .maxScore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.max = .maxScore(v)
        }
      }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularSInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.min {
    case .unboundedMin?: try {
      guard case .unboundedMin(let v)? = self.min else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .minScore?: try {
      guard case .minScore(let v)? = self.min else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.max {
    case .unboundedMax?: try {
      guard case .unboundedMax(let v)? = self.max else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .maxScore?: try {
      guard case .maxScore(let v)? = self.max else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 5)
    }
    if self.count != 0 {
      try visitor.visitSingularSInt32Field(value: self.count, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByScore, rhs: CacheClient__SortedSetFetchRequest._ByScore) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchRequest._ByScore._Score: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchRequest._ByScore.protoMessageName + "._Score"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "exclusive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.exclusive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 1)
    }
    if self.exclusive != false {
      try visitor.visitSingularBoolField(value: self.exclusive, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchRequest._ByScore._Score, rhs: CacheClient__SortedSetFetchRequest._ByScore._Score) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.exclusive != rhs.exclusive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetFetchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetFetchResponse._Found?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetFetchResponse._Missing?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sortedSet {
    case .found?: try {
      guard case .found(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchResponse, rhs: CacheClient__SortedSetFetchResponse) -> Bool {
    if lhs.sortedSet != rhs.sortedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "values_with_scores"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetFetchResponse._Found._ValuesWithScores?
        var hadOneofValue = false
        if let current = self.elements {
          hadOneofValue = true
          if case .valuesWithScores(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.elements = .valuesWithScores(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetFetchResponse._Found._Values?
        var hadOneofValue = false
        if let current = self.elements {
          hadOneofValue = true
          if case .values(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.elements = .values(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.elements {
    case .valuesWithScores?: try {
      guard case .valuesWithScores(let v)? = self.elements else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .values?: try {
      guard case .values(let v)? = self.elements else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchResponse._Found, rhs: CacheClient__SortedSetFetchResponse._Found) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchResponse._Found._ValuesWithScores: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchResponse._Found.protoMessageName + "._ValuesWithScores"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchResponse._Found._ValuesWithScores, rhs: CacheClient__SortedSetFetchResponse._Found._ValuesWithScores) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchResponse._Found._Values: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchResponse._Found.protoMessageName + "._Values"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchResponse._Found._Values, rhs: CacheClient__SortedSetFetchResponse._Found._Values) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetFetchResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetFetchResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetFetchResponse._Missing, rhs: CacheClient__SortedSetFetchResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetScoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetGetScoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetScoreRequest, rhs: CacheClient__SortedSetGetScoreRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetScoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetGetScoreResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetGetScoreResponse._SortedSetFound?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetGetScoreResponse._SortedSetMissing?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sortedSet {
    case .found?: try {
      guard case .found(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetScoreResponse, rhs: CacheClient__SortedSetGetScoreResponse) -> Bool {
    if lhs.sortedSet != rhs.sortedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetScoreResponse._SortedSetGetScoreResponsePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetGetScoreResponse.protoMessageName + "._SortedSetGetScoreResponsePart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .invalid {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.score != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetScoreResponse._SortedSetGetScoreResponsePart, rhs: CacheClient__SortedSetGetScoreResponse._SortedSetGetScoreResponsePart) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetScoreResponse._SortedSetFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetGetScoreResponse.protoMessageName + "._SortedSetFound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetScoreResponse._SortedSetFound, rhs: CacheClient__SortedSetGetScoreResponse._SortedSetFound) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetScoreResponse._SortedSetMissing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetGetScoreResponse.protoMessageName + "._SortedSetMissing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetScoreResponse._SortedSetMissing, rhs: CacheClient__SortedSetGetScoreResponse._SortedSetMissing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetRemoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetRemoveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "all"),
    3: .same(proto: "some"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try {
        var v: CacheClient__SortedSetRemoveRequest._All?
        var hadOneofValue = false
        if let current = self.removeElements {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.removeElements = .all(v)
        }
      }()
      case 3: try {
        var v: CacheClient__SortedSetRemoveRequest._Some?
        var hadOneofValue = false
        if let current = self.removeElements {
          hadOneofValue = true
          if case .some(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.removeElements = .some(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    switch self.removeElements {
    case .all?: try {
      guard case .all(let v)? = self.removeElements else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .some?: try {
      guard case .some(let v)? = self.removeElements else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetRemoveRequest, rhs: CacheClient__SortedSetRemoveRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.removeElements != rhs.removeElements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetRemoveRequest._All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetRemoveRequest.protoMessageName + "._All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetRemoveRequest._All, rhs: CacheClient__SortedSetRemoveRequest._All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetRemoveRequest._Some: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetRemoveRequest.protoMessageName + "._Some"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetRemoveRequest._Some, rhs: CacheClient__SortedSetRemoveRequest._Some) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetRemoveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetRemoveResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetRemoveResponse, rhs: CacheClient__SortedSetRemoveResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetIncrementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetIncrementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "value"),
    3: .same(proto: "amount"),
    4: .standard(proto: "ttl_milliseconds"),
    5: .standard(proto: "refresh_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.ttlMilliseconds) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.refreshTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 3)
    }
    if self.ttlMilliseconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.ttlMilliseconds, fieldNumber: 4)
    }
    if self.refreshTtl != false {
      try visitor.visitSingularBoolField(value: self.refreshTtl, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetIncrementRequest, rhs: CacheClient__SortedSetIncrementRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.ttlMilliseconds != rhs.ttlMilliseconds {return false}
    if lhs.refreshTtl != rhs.refreshTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetIncrementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetIncrementResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularDoubleField(value: self.score, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetIncrementResponse, rhs: CacheClient__SortedSetIncrementResponse) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetRankRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetGetRankRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .same(proto: "value"),
    3: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.order) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if self.order != .ascending {
      try visitor.visitSingularEnumField(value: self.order, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetRankRequest, rhs: CacheClient__SortedSetGetRankRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.value != rhs.value {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetRankRequest.Order: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASCENDING"),
    1: .same(proto: "DESCENDING"),
  ]
}

extension CacheClient__SortedSetGetRankResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetGetRankResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_rank"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetGetRankResponse._RankResponsePart?
        var hadOneofValue = false
        if let current = self.rank {
          hadOneofValue = true
          if case .elementRank(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rank = .elementRank(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetGetRankResponse._SortedSetMissing?
        var hadOneofValue = false
        if let current = self.rank {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rank = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.rank {
    case .elementRank?: try {
      guard case .elementRank(let v)? = self.rank else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.rank else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetRankResponse, rhs: CacheClient__SortedSetGetRankResponse) -> Bool {
    if lhs.rank != rhs.rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetRankResponse._RankResponsePart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetGetRankResponse.protoMessageName + "._RankResponsePart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.rank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .invalid {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.rank != 0 {
      try visitor.visitSingularUInt64Field(value: self.rank, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetRankResponse._RankResponsePart, rhs: CacheClient__SortedSetGetRankResponse._RankResponsePart) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetGetRankResponse._SortedSetMissing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetGetRankResponse.protoMessageName + "._SortedSetMissing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetGetRankResponse._SortedSetMissing, rhs: CacheClient__SortedSetGetRankResponse._SortedSetMissing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetLengthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthRequest, rhs: CacheClient__SortedSetLengthRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetLengthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetLengthResponse._Found?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetLengthResponse._Missing?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sortedSet {
    case .found?: try {
      guard case .found(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthResponse, rhs: CacheClient__SortedSetLengthResponse) -> Bool {
    if lhs.sortedSet != rhs.sortedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetLengthResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthResponse._Found, rhs: CacheClient__SortedSetLengthResponse._Found) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetLengthResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthResponse._Missing, rhs: CacheClient__SortedSetLengthResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthByScoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetLengthByScoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_name"),
    2: .standard(proto: "inclusive_min"),
    3: .standard(proto: "exclusive_min"),
    4: .standard(proto: "unbounded_min"),
    5: .standard(proto: "inclusive_max"),
    6: .standard(proto: "exclusive_max"),
    7: .standard(proto: "unbounded_max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.setName) }()
      case 2: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.min != nil {try decoder.handleConflictingOneOf()}
          self.min = .inclusiveMin(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.min != nil {try decoder.handleConflictingOneOf()}
          self.min = .exclusiveMin(v)
        }
      }()
      case 4: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.min {
          hadOneofValue = true
          if case .unboundedMin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.min = .unboundedMin(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.max != nil {try decoder.handleConflictingOneOf()}
          self.max = .inclusiveMax(v)
        }
      }()
      case 6: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.max != nil {try decoder.handleConflictingOneOf()}
          self.max = .exclusiveMax(v)
        }
      }()
      case 7: try {
        var v: CacheClient__Unbounded?
        var hadOneofValue = false
        if let current = self.max {
          hadOneofValue = true
          if case .unboundedMax(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.max = .unboundedMax(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.setName.isEmpty {
      try visitor.visitSingularBytesField(value: self.setName, fieldNumber: 1)
    }
    switch self.min {
    case .inclusiveMin?: try {
      guard case .inclusiveMin(let v)? = self.min else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .exclusiveMin?: try {
      guard case .exclusiveMin(let v)? = self.min else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .unboundedMin?: try {
      guard case .unboundedMin(let v)? = self.min else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    switch self.max {
    case .inclusiveMax?: try {
      guard case .inclusiveMax(let v)? = self.max else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .exclusiveMax?: try {
      guard case .exclusiveMax(let v)? = self.max else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }()
    case .unboundedMax?: try {
      guard case .unboundedMax(let v)? = self.max else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthByScoreRequest, rhs: CacheClient__SortedSetLengthByScoreRequest) -> Bool {
    if lhs.setName != rhs.setName {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthByScoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SortedSetLengthByScoreResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient__SortedSetLengthByScoreResponse._Found?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .found(v)
        }
      }()
      case 2: try {
        var v: CacheClient__SortedSetLengthByScoreResponse._Missing?
        var hadOneofValue = false
        if let current = self.sortedSet {
          hadOneofValue = true
          if case .missing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sortedSet = .missing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sortedSet {
    case .found?: try {
      guard case .found(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.sortedSet else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthByScoreResponse, rhs: CacheClient__SortedSetLengthByScoreResponse) -> Bool {
    if lhs.sortedSet != rhs.sortedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthByScoreResponse._Found: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetLengthByScoreResponse.protoMessageName + "._Found"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthByScoreResponse._Found, rhs: CacheClient__SortedSetLengthByScoreResponse._Found) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient__SortedSetLengthByScoreResponse._Missing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = CacheClient__SortedSetLengthByScoreResponse.protoMessageName + "._Missing"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient__SortedSetLengthByScoreResponse._Missing, rhs: CacheClient__SortedSetLengthByScoreResponse._Missing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
