// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: permissionmessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Aliases for categories of functionality.
public enum PermissionMessages_CacheRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case cachePermitNone // = 0

  /// Restricts access to apis that read and write data from caches: No higher level resource description or modification.
  case cacheReadWrite // = 1

  /// Restricts access to apis that read from caches: No higher level resource description or modification.
  case cacheReadOnly // = 2

  /// Restricts access to apis that write from caches: No higher level resource description or modification.
  /// Doesn't allow conditional write APIs (SetIfNotExists, IncreaseTTL etc)
  case cacheWriteOnly // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .cachePermitNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cachePermitNone
    case 1: self = .cacheReadWrite
    case 2: self = .cacheReadOnly
    case 3: self = .cacheWriteOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .cachePermitNone: return 0
    case .cacheReadWrite: return 1
    case .cacheReadOnly: return 2
    case .cacheWriteOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_CacheRole] = [
    .cachePermitNone,
    .cacheReadWrite,
    .cacheReadOnly,
    .cacheWriteOnly,
  ]

}

/// Aliases for categories of functionality.
public enum PermissionMessages_TopicRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case topicPermitNone // = 0

  /// Restricts access to apis that read and write data from topics: No higher level resource description or modification.
  case topicReadWrite // = 1

  /// Restricts access to apis that read from topics: No higher level resource description or modification.
  case topicReadOnly // = 2

  /// Restricts access to apis that write from topics: No higher level resource description or modification.
  case topicWriteOnly // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .topicPermitNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .topicPermitNone
    case 1: self = .topicReadWrite
    case 2: self = .topicReadOnly
    case 3: self = .topicWriteOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .topicPermitNone: return 0
    case .topicReadWrite: return 1
    case .topicReadOnly: return 2
    case .topicWriteOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_TopicRole] = [
    .topicPermitNone,
    .topicReadWrite,
    .topicReadOnly,
    .topicWriteOnly,
  ]

}

public enum PermissionMessages_SuperUserPermissions: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case superUser // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .superUser
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .superUser
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .superUser: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_SuperUserPermissions] = [
    .superUser,
  ]

}

public struct PermissionMessages_Permissions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: PermissionMessages_Permissions.OneOf_Kind? = nil

  public var superUser: PermissionMessages_SuperUserPermissions {
    get {
      if case .superUser(let v)? = kind {return v}
      return .superUser
    }
    set {kind = .superUser(newValue)}
  }

  public var explicit: PermissionMessages_ExplicitPermissions {
    get {
      if case .explicit(let v)? = kind {return v}
      return PermissionMessages_ExplicitPermissions()
    }
    set {kind = .explicit(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, Sendable {
    case superUser(PermissionMessages_SuperUserPermissions)
    case explicit(PermissionMessages_ExplicitPermissions)

  }

  public init() {}
}

public struct PermissionMessages_ExplicitPermissions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var permissions: [PermissionMessages_PermissionsType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PermissionMessages_PermissionsType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: PermissionMessages_PermissionsType.OneOf_Kind? = nil

  public var cachePermissions: PermissionMessages_PermissionsType.CachePermissions {
    get {
      if case .cachePermissions(let v)? = kind {return v}
      return PermissionMessages_PermissionsType.CachePermissions()
    }
    set {kind = .cachePermissions(newValue)}
  }

  public var topicPermissions: PermissionMessages_PermissionsType.TopicPermissions {
    get {
      if case .topicPermissions(let v)? = kind {return v}
      return PermissionMessages_PermissionsType.TopicPermissions()
    }
    set {kind = .topicPermissions(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, Sendable {
    case cachePermissions(PermissionMessages_PermissionsType.CachePermissions)
    case topicPermissions(PermissionMessages_PermissionsType.TopicPermissions)

  }

  public struct All: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CacheSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.CacheSelector.OneOf_Kind? = nil

    public var cacheName: String {
      get {
        if case .cacheName(let v)? = kind {return v}
        return String()
      }
      set {kind = .cacheName(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case cacheName(String)

    }

    public init() {}
  }

  public struct CacheItemSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.CacheItemSelector.OneOf_Kind? = nil

    public var key: Data {
      get {
        if case .key(let v)? = kind {return v}
        return Data()
      }
      set {kind = .key(newValue)}
    }

    public var keyPrefix: Data {
      get {
        if case .keyPrefix(let v)? = kind {return v}
        return Data()
      }
      set {kind = .keyPrefix(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case key(Data)
      case keyPrefix(Data)

    }

    public init() {}
  }

  public struct CachePermissions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var role: PermissionMessages_CacheRole = .cachePermitNone

    public var cache: PermissionMessages_PermissionsType.CachePermissions.OneOf_Cache? = nil

    public var allCaches: PermissionMessages_PermissionsType.All {
      get {
        if case .allCaches(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cache = .allCaches(newValue)}
    }

    public var cacheSelector: PermissionMessages_PermissionsType.CacheSelector {
      get {
        if case .cacheSelector(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.CacheSelector()
      }
      set {cache = .cacheSelector(newValue)}
    }

    public var cacheItem: PermissionMessages_PermissionsType.CachePermissions.OneOf_CacheItem? = nil

    public var allItems: PermissionMessages_PermissionsType.All {
      get {
        if case .allItems(let v)? = cacheItem {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cacheItem = .allItems(newValue)}
    }

    public var itemSelector: PermissionMessages_PermissionsType.CacheItemSelector {
      get {
        if case .itemSelector(let v)? = cacheItem {return v}
        return PermissionMessages_PermissionsType.CacheItemSelector()
      }
      set {cacheItem = .itemSelector(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Cache: Equatable, Sendable {
      case allCaches(PermissionMessages_PermissionsType.All)
      case cacheSelector(PermissionMessages_PermissionsType.CacheSelector)

    }

    public enum OneOf_CacheItem: Equatable, Sendable {
      case allItems(PermissionMessages_PermissionsType.All)
      case itemSelector(PermissionMessages_PermissionsType.CacheItemSelector)

    }

    public init() {}
  }

  public struct TopicSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.TopicSelector.OneOf_Kind? = nil

    public var topicName: String {
      get {
        if case .topicName(let v)? = kind {return v}
        return String()
      }
      set {kind = .topicName(newValue)}
    }

    public var topicNamePrefix: String {
      get {
        if case .topicNamePrefix(let v)? = kind {return v}
        return String()
      }
      set {kind = .topicNamePrefix(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable, Sendable {
      case topicName(String)
      case topicNamePrefix(String)

    }

    public init() {}
  }

  public struct TopicPermissions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var role: PermissionMessages_TopicRole = .topicPermitNone

    public var cache: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Cache? = nil

    public var allCaches: PermissionMessages_PermissionsType.All {
      get {
        if case .allCaches(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cache = .allCaches(newValue)}
    }

    public var cacheSelector: PermissionMessages_PermissionsType.CacheSelector {
      get {
        if case .cacheSelector(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.CacheSelector()
      }
      set {cache = .cacheSelector(newValue)}
    }

    public var topic: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Topic? = nil

    public var allTopics: PermissionMessages_PermissionsType.All {
      get {
        if case .allTopics(let v)? = topic {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {topic = .allTopics(newValue)}
    }

    public var topicSelector: PermissionMessages_PermissionsType.TopicSelector {
      get {
        if case .topicSelector(let v)? = topic {return v}
        return PermissionMessages_PermissionsType.TopicSelector()
      }
      set {topic = .topicSelector(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Cache: Equatable, Sendable {
      case allCaches(PermissionMessages_PermissionsType.All)
      case cacheSelector(PermissionMessages_PermissionsType.CacheSelector)

    }

    public enum OneOf_Topic: Equatable, Sendable {
      case allTopics(PermissionMessages_PermissionsType.All)
      case topicSelector(PermissionMessages_PermissionsType.TopicSelector)

    }

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "permission_messages"

extension PermissionMessages_CacheRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CachePermitNone\0\u{1}CacheReadWrite\0\u{1}CacheReadOnly\0\u{1}CacheWriteOnly\0")
}

extension PermissionMessages_TopicRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TopicPermitNone\0\u{1}TopicReadWrite\0\u{1}TopicReadOnly\0\u{1}TopicWriteOnly\0")
}

extension PermissionMessages_SuperUserPermissions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SuperUser\0")
}

extension PermissionMessages_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permissions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}super_user\0\u{1}explicit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PermissionMessages_SuperUserPermissions?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .superUser(v)
        }
      }()
      case 2: try {
        var v: PermissionMessages_ExplicitPermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .explicit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .explicit(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .superUser?: try {
      guard case .superUser(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .explicit?: try {
      guard case .explicit(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_Permissions, rhs: PermissionMessages_Permissions) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_ExplicitPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplicitPermissions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}permissions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_ExplicitPermissions, rhs: PermissionMessages_ExplicitPermissions) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermissionsType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cache_permissions\0\u{3}topic_permissions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PermissionMessages_PermissionsType.CachePermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .cachePermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .cachePermissions(v)
        }
      }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.TopicPermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .topicPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .topicPermissions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .cachePermissions?: try {
      guard case .cachePermissions(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .topicPermissions?: try {
      guard case .topicPermissions(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType, rhs: PermissionMessages_PermissionsType) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.All, rhs: PermissionMessages_PermissionsType.All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CacheSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CacheSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cache_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .cacheName(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .cacheName(let v)? = self.kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CacheSelector, rhs: PermissionMessages_PermissionsType.CacheSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CacheItemSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CacheItemSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}key_prefix\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .key(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .keyPrefix(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .key?: try {
      guard case .key(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .keyPrefix?: try {
      guard case .keyPrefix(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CacheItemSelector, rhs: PermissionMessages_PermissionsType.CacheItemSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CachePermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CachePermissions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}role\0\u{3}all_caches\0\u{3}cache_selector\0\u{3}all_items\0\u{3}item_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .allCaches(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .allCaches(v)
        }
      }()
      case 3: try {
        var v: PermissionMessages_PermissionsType.CacheSelector?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .cacheSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .cacheSelector(v)
        }
      }()
      case 4: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cacheItem {
          hadOneofValue = true
          if case .allItems(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cacheItem = .allItems(v)
        }
      }()
      case 5: try {
        var v: PermissionMessages_PermissionsType.CacheItemSelector?
        var hadOneofValue = false
        if let current = self.cacheItem {
          hadOneofValue = true
          if case .itemSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cacheItem = .itemSelector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.role != .cachePermitNone {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    switch self.cache {
    case .allCaches?: try {
      guard case .allCaches(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cacheSelector?: try {
      guard case .cacheSelector(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.cacheItem {
    case .allItems?: try {
      guard case .allItems(let v)? = self.cacheItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .itemSelector?: try {
      guard case .itemSelector(let v)? = self.cacheItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CachePermissions, rhs: PermissionMessages_PermissionsType.CachePermissions) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.cache != rhs.cache {return false}
    if lhs.cacheItem != rhs.cacheItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.TopicSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".TopicSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}topic_name\0\u{3}topic_name_prefix\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .topicName(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .topicNamePrefix(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .topicName?: try {
      guard case .topicName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .topicNamePrefix?: try {
      guard case .topicNamePrefix(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.TopicSelector, rhs: PermissionMessages_PermissionsType.TopicSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.TopicPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".TopicPermissions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}role\0\u{3}all_caches\0\u{3}cache_selector\0\u{3}all_topics\0\u{3}topic_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .allCaches(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .allCaches(v)
        }
      }()
      case 3: try {
        var v: PermissionMessages_PermissionsType.CacheSelector?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .cacheSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .cacheSelector(v)
        }
      }()
      case 4: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.topic {
          hadOneofValue = true
          if case .allTopics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.topic = .allTopics(v)
        }
      }()
      case 5: try {
        var v: PermissionMessages_PermissionsType.TopicSelector?
        var hadOneofValue = false
        if let current = self.topic {
          hadOneofValue = true
          if case .topicSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.topic = .topicSelector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.role != .topicPermitNone {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    switch self.cache {
    case .allCaches?: try {
      guard case .allCaches(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cacheSelector?: try {
      guard case .cacheSelector(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.topic {
    case .allTopics?: try {
      guard case .allTopics(let v)? = self.topic else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .topicSelector?: try {
      guard case .topicSelector(let v)? = self.topic else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.TopicPermissions, rhs: PermissionMessages_PermissionsType.TopicPermissions) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.cache != rhs.cache {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
