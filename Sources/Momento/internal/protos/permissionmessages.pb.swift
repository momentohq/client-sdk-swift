// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: permissionmessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Aliases for categories of functionality.
public enum PermissionMessages_CacheRole: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case cachePermitNone // = 0

  /// Restricts access to apis that read and write data from caches: No higher level resource description or modification.
  case cacheReadWrite // = 1

  /// Restricts access to apis that read from caches: No higher level resource description or modification.
  case cacheReadOnly // = 2

  /// Restricts access to apis that write from caches: No higher level resource description or modification.
  /// Doesn't allow conditional write APIs (SetIfNotExists, IncreaseTTL etc)
  case cacheWriteOnly // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .cachePermitNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cachePermitNone
    case 1: self = .cacheReadWrite
    case 2: self = .cacheReadOnly
    case 3: self = .cacheWriteOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .cachePermitNone: return 0
    case .cacheReadWrite: return 1
    case .cacheReadOnly: return 2
    case .cacheWriteOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PermissionMessages_CacheRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_CacheRole] = [
    .cachePermitNone,
    .cacheReadWrite,
    .cacheReadOnly,
    .cacheWriteOnly,
  ]
}

#endif  // swift(>=4.2)

/// Aliases for categories of functionality.
public enum PermissionMessages_TopicRole: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case topicPermitNone // = 0

  /// Restricts access to apis that read and write data from topics: No higher level resource description or modification.
  case topicReadWrite // = 1

  /// Restricts access to apis that read from topics: No higher level resource description or modification.
  case topicReadOnly // = 2

  /// Restricts access to apis that write from topics: No higher level resource description or modification.
  case topicWriteOnly // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .topicPermitNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .topicPermitNone
    case 1: self = .topicReadWrite
    case 2: self = .topicReadOnly
    case 3: self = .topicWriteOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .topicPermitNone: return 0
    case .topicReadWrite: return 1
    case .topicReadOnly: return 2
    case .topicWriteOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PermissionMessages_TopicRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_TopicRole] = [
    .topicPermitNone,
    .topicReadWrite,
    .topicReadOnly,
    .topicWriteOnly,
  ]
}

#endif  // swift(>=4.2)

public enum PermissionMessages_SuperUserPermissions: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case superUser // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .superUser
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .superUser
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .superUser: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PermissionMessages_SuperUserPermissions: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PermissionMessages_SuperUserPermissions] = [
    .superUser,
  ]
}

#endif  // swift(>=4.2)

public struct PermissionMessages_Permissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: PermissionMessages_Permissions.OneOf_Kind? = nil

  public var superUser: PermissionMessages_SuperUserPermissions {
    get {
      if case .superUser(let v)? = kind {return v}
      return .superUser
    }
    set {kind = .superUser(newValue)}
  }

  public var explicit: PermissionMessages_ExplicitPermissions {
    get {
      if case .explicit(let v)? = kind {return v}
      return PermissionMessages_ExplicitPermissions()
    }
    set {kind = .explicit(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case superUser(PermissionMessages_SuperUserPermissions)
    case explicit(PermissionMessages_ExplicitPermissions)

  #if !swift(>=4.1)
    public static func ==(lhs: PermissionMessages_Permissions.OneOf_Kind, rhs: PermissionMessages_Permissions.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.superUser, .superUser): return {
        guard case .superUser(let l) = lhs, case .superUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.explicit, .explicit): return {
        guard case .explicit(let l) = lhs, case .explicit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PermissionMessages_ExplicitPermissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var permissions: [PermissionMessages_PermissionsType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PermissionMessages_PermissionsType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: PermissionMessages_PermissionsType.OneOf_Kind? = nil

  public var cachePermissions: PermissionMessages_PermissionsType.CachePermissions {
    get {
      if case .cachePermissions(let v)? = kind {return v}
      return PermissionMessages_PermissionsType.CachePermissions()
    }
    set {kind = .cachePermissions(newValue)}
  }

  public var topicPermissions: PermissionMessages_PermissionsType.TopicPermissions {
    get {
      if case .topicPermissions(let v)? = kind {return v}
      return PermissionMessages_PermissionsType.TopicPermissions()
    }
    set {kind = .topicPermissions(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case cachePermissions(PermissionMessages_PermissionsType.CachePermissions)
    case topicPermissions(PermissionMessages_PermissionsType.TopicPermissions)

  #if !swift(>=4.1)
    public static func ==(lhs: PermissionMessages_PermissionsType.OneOf_Kind, rhs: PermissionMessages_PermissionsType.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cachePermissions, .cachePermissions): return {
        guard case .cachePermissions(let l) = lhs, case .cachePermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.topicPermissions, .topicPermissions): return {
        guard case .topicPermissions(let l) = lhs, case .topicPermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct All {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CacheSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.CacheSelector.OneOf_Kind? = nil

    public var cacheName: String {
      get {
        if case .cacheName(let v)? = kind {return v}
        return String()
      }
      set {kind = .cacheName(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case cacheName(String)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.CacheSelector.OneOf_Kind, rhs: PermissionMessages_PermissionsType.CacheSelector.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.cacheName, .cacheName): return {
          guard case .cacheName(let l) = lhs, case .cacheName(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public struct CacheItemSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.CacheItemSelector.OneOf_Kind? = nil

    public var key: Data {
      get {
        if case .key(let v)? = kind {return v}
        return Data()
      }
      set {kind = .key(newValue)}
    }

    public var keyPrefix: Data {
      get {
        if case .keyPrefix(let v)? = kind {return v}
        return Data()
      }
      set {kind = .keyPrefix(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case key(Data)
      case keyPrefix(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.CacheItemSelector.OneOf_Kind, rhs: PermissionMessages_PermissionsType.CacheItemSelector.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.key, .key): return {
          guard case .key(let l) = lhs, case .key(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.keyPrefix, .keyPrefix): return {
          guard case .keyPrefix(let l) = lhs, case .keyPrefix(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct CachePermissions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var role: PermissionMessages_CacheRole = .cachePermitNone

    public var cache: PermissionMessages_PermissionsType.CachePermissions.OneOf_Cache? = nil

    public var allCaches: PermissionMessages_PermissionsType.All {
      get {
        if case .allCaches(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cache = .allCaches(newValue)}
    }

    public var cacheSelector: PermissionMessages_PermissionsType.CacheSelector {
      get {
        if case .cacheSelector(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.CacheSelector()
      }
      set {cache = .cacheSelector(newValue)}
    }

    public var cacheItem: PermissionMessages_PermissionsType.CachePermissions.OneOf_CacheItem? = nil

    public var allItems: PermissionMessages_PermissionsType.All {
      get {
        if case .allItems(let v)? = cacheItem {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cacheItem = .allItems(newValue)}
    }

    public var itemSelector: PermissionMessages_PermissionsType.CacheItemSelector {
      get {
        if case .itemSelector(let v)? = cacheItem {return v}
        return PermissionMessages_PermissionsType.CacheItemSelector()
      }
      set {cacheItem = .itemSelector(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Cache: Equatable {
      case allCaches(PermissionMessages_PermissionsType.All)
      case cacheSelector(PermissionMessages_PermissionsType.CacheSelector)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.CachePermissions.OneOf_Cache, rhs: PermissionMessages_PermissionsType.CachePermissions.OneOf_Cache) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.allCaches, .allCaches): return {
          guard case .allCaches(let l) = lhs, case .allCaches(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cacheSelector, .cacheSelector): return {
          guard case .cacheSelector(let l) = lhs, case .cacheSelector(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_CacheItem: Equatable {
      case allItems(PermissionMessages_PermissionsType.All)
      case itemSelector(PermissionMessages_PermissionsType.CacheItemSelector)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.CachePermissions.OneOf_CacheItem, rhs: PermissionMessages_PermissionsType.CachePermissions.OneOf_CacheItem) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.allItems, .allItems): return {
          guard case .allItems(let l) = lhs, case .allItems(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.itemSelector, .itemSelector): return {
          guard case .itemSelector(let l) = lhs, case .itemSelector(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct TopicSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: PermissionMessages_PermissionsType.TopicSelector.OneOf_Kind? = nil

    public var topicName: String {
      get {
        if case .topicName(let v)? = kind {return v}
        return String()
      }
      set {kind = .topicName(newValue)}
    }

    public var topicNamePrefix: String {
      get {
        if case .topicNamePrefix(let v)? = kind {return v}
        return String()
      }
      set {kind = .topicNamePrefix(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case topicName(String)
      case topicNamePrefix(String)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.TopicSelector.OneOf_Kind, rhs: PermissionMessages_PermissionsType.TopicSelector.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.topicName, .topicName): return {
          guard case .topicName(let l) = lhs, case .topicName(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.topicNamePrefix, .topicNamePrefix): return {
          guard case .topicNamePrefix(let l) = lhs, case .topicNamePrefix(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct TopicPermissions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var role: PermissionMessages_TopicRole = .topicPermitNone

    public var cache: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Cache? = nil

    public var allCaches: PermissionMessages_PermissionsType.All {
      get {
        if case .allCaches(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {cache = .allCaches(newValue)}
    }

    public var cacheSelector: PermissionMessages_PermissionsType.CacheSelector {
      get {
        if case .cacheSelector(let v)? = cache {return v}
        return PermissionMessages_PermissionsType.CacheSelector()
      }
      set {cache = .cacheSelector(newValue)}
    }

    public var topic: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Topic? = nil

    public var allTopics: PermissionMessages_PermissionsType.All {
      get {
        if case .allTopics(let v)? = topic {return v}
        return PermissionMessages_PermissionsType.All()
      }
      set {topic = .allTopics(newValue)}
    }

    public var topicSelector: PermissionMessages_PermissionsType.TopicSelector {
      get {
        if case .topicSelector(let v)? = topic {return v}
        return PermissionMessages_PermissionsType.TopicSelector()
      }
      set {topic = .topicSelector(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Cache: Equatable {
      case allCaches(PermissionMessages_PermissionsType.All)
      case cacheSelector(PermissionMessages_PermissionsType.CacheSelector)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Cache, rhs: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Cache) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.allCaches, .allCaches): return {
          guard case .allCaches(let l) = lhs, case .allCaches(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cacheSelector, .cacheSelector): return {
          guard case .cacheSelector(let l) = lhs, case .cacheSelector(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_Topic: Equatable {
      case allTopics(PermissionMessages_PermissionsType.All)
      case topicSelector(PermissionMessages_PermissionsType.TopicSelector)

    #if !swift(>=4.1)
      public static func ==(lhs: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Topic, rhs: PermissionMessages_PermissionsType.TopicPermissions.OneOf_Topic) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.allTopics, .allTopics): return {
          guard case .allTopics(let l) = lhs, case .allTopics(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.topicSelector, .topicSelector): return {
          guard case .topicSelector(let l) = lhs, case .topicSelector(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PermissionMessages_CacheRole: @unchecked Sendable {}
extension PermissionMessages_TopicRole: @unchecked Sendable {}
extension PermissionMessages_SuperUserPermissions: @unchecked Sendable {}
extension PermissionMessages_Permissions: @unchecked Sendable {}
extension PermissionMessages_Permissions.OneOf_Kind: @unchecked Sendable {}
extension PermissionMessages_ExplicitPermissions: @unchecked Sendable {}
extension PermissionMessages_PermissionsType: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.OneOf_Kind: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.All: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CacheSelector: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CacheSelector.OneOf_Kind: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CacheItemSelector: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CacheItemSelector.OneOf_Kind: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CachePermissions: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CachePermissions.OneOf_Cache: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.CachePermissions.OneOf_CacheItem: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.TopicSelector: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.TopicSelector.OneOf_Kind: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.TopicPermissions: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.TopicPermissions.OneOf_Cache: @unchecked Sendable {}
extension PermissionMessages_PermissionsType.TopicPermissions.OneOf_Topic: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "permission_messages"

extension PermissionMessages_CacheRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CachePermitNone"),
    1: .same(proto: "CacheReadWrite"),
    2: .same(proto: "CacheReadOnly"),
    3: .same(proto: "CacheWriteOnly"),
  ]
}

extension PermissionMessages_TopicRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TopicPermitNone"),
    1: .same(proto: "TopicReadWrite"),
    2: .same(proto: "TopicReadOnly"),
    3: .same(proto: "TopicWriteOnly"),
  ]
}

extension PermissionMessages_SuperUserPermissions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SuperUser"),
  ]
}

extension PermissionMessages_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "super_user"),
    2: .same(proto: "explicit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PermissionMessages_SuperUserPermissions?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .superUser(v)
        }
      }()
      case 2: try {
        var v: PermissionMessages_ExplicitPermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .explicit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .explicit(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .superUser?: try {
      guard case .superUser(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .explicit?: try {
      guard case .explicit(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_Permissions, rhs: PermissionMessages_Permissions) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_ExplicitPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplicitPermissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_ExplicitPermissions, rhs: PermissionMessages_ExplicitPermissions) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermissionsType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_permissions"),
    2: .standard(proto: "topic_permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PermissionMessages_PermissionsType.CachePermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .cachePermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .cachePermissions(v)
        }
      }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.TopicPermissions?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .topicPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .topicPermissions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .cachePermissions?: try {
      guard case .cachePermissions(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .topicPermissions?: try {
      guard case .topicPermissions(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType, rhs: PermissionMessages_PermissionsType) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.All: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".All"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.All, rhs: PermissionMessages_PermissionsType.All) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CacheSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CacheSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .cacheName(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .cacheName(let v)? = self.kind {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CacheSelector, rhs: PermissionMessages_PermissionsType.CacheSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CacheItemSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CacheItemSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "key_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .key(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .keyPrefix(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .key?: try {
      guard case .key(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .keyPrefix?: try {
      guard case .keyPrefix(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CacheItemSelector, rhs: PermissionMessages_PermissionsType.CacheItemSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.CachePermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".CachePermissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .standard(proto: "all_caches"),
    3: .standard(proto: "cache_selector"),
    4: .standard(proto: "all_items"),
    5: .standard(proto: "item_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .allCaches(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .allCaches(v)
        }
      }()
      case 3: try {
        var v: PermissionMessages_PermissionsType.CacheSelector?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .cacheSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .cacheSelector(v)
        }
      }()
      case 4: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cacheItem {
          hadOneofValue = true
          if case .allItems(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cacheItem = .allItems(v)
        }
      }()
      case 5: try {
        var v: PermissionMessages_PermissionsType.CacheItemSelector?
        var hadOneofValue = false
        if let current = self.cacheItem {
          hadOneofValue = true
          if case .itemSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cacheItem = .itemSelector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.role != .cachePermitNone {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    switch self.cache {
    case .allCaches?: try {
      guard case .allCaches(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cacheSelector?: try {
      guard case .cacheSelector(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.cacheItem {
    case .allItems?: try {
      guard case .allItems(let v)? = self.cacheItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .itemSelector?: try {
      guard case .itemSelector(let v)? = self.cacheItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.CachePermissions, rhs: PermissionMessages_PermissionsType.CachePermissions) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.cache != rhs.cache {return false}
    if lhs.cacheItem != rhs.cacheItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.TopicSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".TopicSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_name"),
    2: .standard(proto: "topic_name_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .topicName(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .topicNamePrefix(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .topicName?: try {
      guard case .topicName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .topicNamePrefix?: try {
      guard case .topicNamePrefix(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.TopicSelector, rhs: PermissionMessages_PermissionsType.TopicSelector) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionMessages_PermissionsType.TopicPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = PermissionMessages_PermissionsType.protoMessageName + ".TopicPermissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .standard(proto: "all_caches"),
    3: .standard(proto: "cache_selector"),
    4: .standard(proto: "all_topics"),
    5: .standard(proto: "topic_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .allCaches(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .allCaches(v)
        }
      }()
      case 3: try {
        var v: PermissionMessages_PermissionsType.CacheSelector?
        var hadOneofValue = false
        if let current = self.cache {
          hadOneofValue = true
          if case .cacheSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cache = .cacheSelector(v)
        }
      }()
      case 4: try {
        var v: PermissionMessages_PermissionsType.All?
        var hadOneofValue = false
        if let current = self.topic {
          hadOneofValue = true
          if case .allTopics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.topic = .allTopics(v)
        }
      }()
      case 5: try {
        var v: PermissionMessages_PermissionsType.TopicSelector?
        var hadOneofValue = false
        if let current = self.topic {
          hadOneofValue = true
          if case .topicSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.topic = .topicSelector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.role != .topicPermitNone {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    switch self.cache {
    case .allCaches?: try {
      guard case .allCaches(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cacheSelector?: try {
      guard case .cacheSelector(let v)? = self.cache else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.topic {
    case .allTopics?: try {
      guard case .allTopics(let v)? = self.topic else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .topicSelector?: try {
      guard case .topicSelector(let v)? = self.topic else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PermissionMessages_PermissionsType.TopicPermissions, rhs: PermissionMessages_PermissionsType.TopicPermissions) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.cache != rhs.cache {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
