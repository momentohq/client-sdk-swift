// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cachepubsub.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A value to publish through a topic.
public struct CacheClient_Pubsub__PublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cache namespace for the topic to which you want to send the value.
  public var cacheName: String = String()

  /// The literal topic name to which you want to send the value.
  public var topic: String = String()

  /// The value you want to send to the topic. All current subscribers will receive
  /// this, should the whims of the Internet prove merciful.
  public var value: CacheClient_Pubsub__TopicValue {
    get {return _value ?? CacheClient_Pubsub__TopicValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: CacheClient_Pubsub__TopicValue? = nil
}

/// A description of how you want to subscribe to a topic.
public struct CacheClient_Pubsub__SubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cache namespace for the topic to which you want to subscribe.
  public var cacheName: String = String()

  /// The literal topic name to which you want to subscribe.
  public var topic: String = String()

  /// If provided, attempt to reconnect to the topic and replay messages starting from
  /// the provided sequence number. You may get a discontinuity if some (or all) of the
  /// messages are not available.
  /// If provided at 1, you may receive some messages leading up to whatever the
  /// newest message is. The exact amount is unspecified and subject to change.
  /// If not provided (or 0), the subscription will begin with the latest messages.
  public var resumeAtTopicSequenceNumber: UInt64 = 0

  /// Determined by the service when a topic is created. This clarifies the intent of
  /// a subscription, and ensures the right messages are sent for a given
  /// `resume_at_topic_sequence_number`.
  /// Include this in your Subscribe() calls when you are reconnecting. The right value
  /// is the last sequence_page you received.
  public var sequencePage: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Possible message kinds from a topic. They can be items when they're from you, or
/// other kinds when we have something we think you might need to know about the
/// subscription's status.
public struct CacheClient_Pubsub__SubscriptionItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: CacheClient_Pubsub__SubscriptionItem.OneOf_Kind? = nil

  /// The subscription has yielded an item you previously published.
  public var item: CacheClient_Pubsub__TopicItem {
    get {
      if case .item(let v)? = kind {return v}
      return CacheClient_Pubsub__TopicItem()
    }
    set {kind = .item(newValue)}
  }

  /// Momento wants to let you know we detected some possible inconsistency at this
  /// point in the subscription stream.
  ///
  /// A lack of a discontinuity does not mean the subscription is guaranteed to be
  /// strictly perfect, but the presence of a discontinuity is very likely to
  public var discontinuity: CacheClient_Pubsub__Discontinuity {
    get {
      if case .discontinuity(let v)? = kind {return v}
      return CacheClient_Pubsub__Discontinuity()
    }
    set {kind = .discontinuity(newValue)}
  }

  /// The stream is still working, there's nothing to see here.
  public var heartbeat: CacheClient_Pubsub__Heartbeat {
    get {
      if case .heartbeat(let v)? = kind {return v}
      return CacheClient_Pubsub__Heartbeat()
    }
    set {kind = .heartbeat(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// The subscription has yielded an item you previously published.
    case item(CacheClient_Pubsub__TopicItem)
    /// Momento wants to let you know we detected some possible inconsistency at this
    /// point in the subscription stream.
    ///
    /// A lack of a discontinuity does not mean the subscription is guaranteed to be
    /// strictly perfect, but the presence of a discontinuity is very likely to
    case discontinuity(CacheClient_Pubsub__Discontinuity)
    /// The stream is still working, there's nothing to see here.
    case heartbeat(CacheClient_Pubsub__Heartbeat)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient_Pubsub__SubscriptionItem.OneOf_Kind, rhs: CacheClient_Pubsub__SubscriptionItem.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.item, .item): return {
        guard case .item(let l) = lhs, case .item(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discontinuity, .discontinuity): return {
        guard case .discontinuity(let l) = lhs, case .discontinuity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.heartbeat, .heartbeat): return {
        guard case .heartbeat(let l) = lhs, case .heartbeat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Your subscription has yielded an item you previously published. Here it is!
public struct CacheClient_Pubsub__TopicItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Topic sequence numbers give an order of messages per-topic.
  /// All subscribers to a topic will receive messages in the same order, with the same sequence numbers.
  public var topicSequenceNumber: UInt64 = 0

  /// The value you previously published to this topic.
  public var value: CacheClient_Pubsub__TopicValue {
    get {return _value ?? CacheClient_Pubsub__TopicValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  /// Authenticated id from Publisher's disposable token
  public var publisherID: String = String()

  /// Sequence pages exist to determine which sequence number range a message belongs to. On a topic reset,
  /// the sequence numbers reset and a new sequence_page is given.
  /// For a given sequence_page, the next message in a topic is topic_sequence_number + 1.
  ///
  /// Later sequence pages are numbered greater than earlier pages, but they don't go one-by-one.
  public var sequencePage: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: CacheClient_Pubsub__TopicValue? = nil
}

/// A value in a topic - published, duplicated and received in a subscription.
public struct CacheClient_Pubsub__TopicValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Types of messages a topic may relay. You can mix types or you can make conventionally
  /// typed topics. Sticking with one kind will generally make your software easier to work
  /// with though, so we recommend picking the kind you like and using it for a topic!
  public var kind: CacheClient_Pubsub__TopicValue.OneOf_Kind? = nil

  public var text: String {
    get {
      if case .text(let v)? = kind {return v}
      return String()
    }
    set {kind = .text(newValue)}
  }

  public var binary: Data {
    get {
      if case .binary(let v)? = kind {return v}
      return Data()
    }
    set {kind = .binary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of messages a topic may relay. You can mix types or you can make conventionally
  /// typed topics. Sticking with one kind will generally make your software easier to work
  /// with though, so we recommend picking the kind you like and using it for a topic!
  public enum OneOf_Kind: Equatable {
    case text(String)
    case binary(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: CacheClient_Pubsub__TopicValue.OneOf_Kind, rhs: CacheClient_Pubsub__TopicValue.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A message from Momento when we know a subscription to have skipped some messages.
/// We don't terminate your subscription in that case, but just in case you care, we
/// do our best to let you know about it.
public struct CacheClient_Pubsub__Discontinuity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The last topic value sequence number known to have been attempted (if known, 0 otherwise).
  public var lastTopicSequence: UInt64 = 0

  /// The new topic sequence number after which TopicItems will ostensibly resume.
  public var newTopicSequence: UInt64 = 0

  /// The new topic sequence_page. If you had one before and this one is different, then your topic reset.
  /// If you didn't have one, then this is just telling you what the sequence page is expected to be.
  /// If you had one before, and this one is the same, then it's just telling you that you missed some messages
  /// in the topic. Probably your client is consuming messages a little too slowly in this case!
  public var newSequencePage: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message from Momento for when we want to reassure clients or frameworks that a
/// Subscription is still healthy.
/// These are synthetic meta-events and do not increase the topic sequence count.
/// Different subscribers may receive a different cadence of heartbeat, and no guarantee
/// is made about the cadence or even presence or absence of heartbeats in a stream.
/// They are a tool for helping ensure that socket timeouts and the like don't impact
/// subscriptions you may care about, but that aren't receiving a substantial publish rate.
public struct CacheClient_Pubsub__Heartbeat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CacheClient_Pubsub__PublishRequest: @unchecked Sendable {}
extension CacheClient_Pubsub__SubscriptionRequest: @unchecked Sendable {}
extension CacheClient_Pubsub__SubscriptionItem: @unchecked Sendable {}
extension CacheClient_Pubsub__SubscriptionItem.OneOf_Kind: @unchecked Sendable {}
extension CacheClient_Pubsub__TopicItem: @unchecked Sendable {}
extension CacheClient_Pubsub__TopicValue: @unchecked Sendable {}
extension CacheClient_Pubsub__TopicValue.OneOf_Kind: @unchecked Sendable {}
extension CacheClient_Pubsub__Discontinuity: @unchecked Sendable {}
extension CacheClient_Pubsub__Heartbeat: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cache_client.pubsub"

extension CacheClient_Pubsub__PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._PublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
    2: .same(proto: "topic"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__PublishRequest, rhs: CacheClient_Pubsub__PublishRequest) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__SubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SubscriptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cache_name"),
    2: .same(proto: "topic"),
    3: .standard(proto: "resume_at_topic_sequence_number"),
    4: .standard(proto: "sequence_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacheName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.resumeAtTopicSequenceNumber) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.sequencePage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cacheName.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheName, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.resumeAtTopicSequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.resumeAtTopicSequenceNumber, fieldNumber: 3)
    }
    if self.sequencePage != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequencePage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__SubscriptionRequest, rhs: CacheClient_Pubsub__SubscriptionRequest) -> Bool {
    if lhs.cacheName != rhs.cacheName {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.resumeAtTopicSequenceNumber != rhs.resumeAtTopicSequenceNumber {return false}
    if lhs.sequencePage != rhs.sequencePage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__SubscriptionItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._SubscriptionItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .same(proto: "discontinuity"),
    3: .same(proto: "heartbeat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CacheClient_Pubsub__TopicItem?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .item(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .item(v)
        }
      }()
      case 2: try {
        var v: CacheClient_Pubsub__Discontinuity?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .discontinuity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .discontinuity(v)
        }
      }()
      case 3: try {
        var v: CacheClient_Pubsub__Heartbeat?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .heartbeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .heartbeat(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .item?: try {
      guard case .item(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .discontinuity?: try {
      guard case .discontinuity(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .heartbeat?: try {
      guard case .heartbeat(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__SubscriptionItem, rhs: CacheClient_Pubsub__SubscriptionItem) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__TopicItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._TopicItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_sequence_number"),
    2: .same(proto: "value"),
    3: .standard(proto: "publisher_id"),
    4: .standard(proto: "sequence_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.topicSequenceNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publisherID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.sequencePage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.topicSequenceNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.topicSequenceNumber, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.publisherID.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherID, fieldNumber: 3)
    }
    if self.sequencePage != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequencePage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__TopicItem, rhs: CacheClient_Pubsub__TopicItem) -> Bool {
    if lhs.topicSequenceNumber != rhs.topicSequenceNumber {return false}
    if lhs._value != rhs._value {return false}
    if lhs.publisherID != rhs.publisherID {return false}
    if lhs.sequencePage != rhs.sequencePage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__TopicValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._TopicValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "binary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .text(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .binary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .text?: try {
      guard case .text(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__TopicValue, rhs: CacheClient_Pubsub__TopicValue) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__Discontinuity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Discontinuity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_topic_sequence"),
    2: .standard(proto: "new_topic_sequence"),
    3: .standard(proto: "new_sequence_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.lastTopicSequence) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.newTopicSequence) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.newSequencePage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastTopicSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastTopicSequence, fieldNumber: 1)
    }
    if self.newTopicSequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.newTopicSequence, fieldNumber: 2)
    }
    if self.newSequencePage != 0 {
      try visitor.visitSingularUInt64Field(value: self.newSequencePage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__Discontinuity, rhs: CacheClient_Pubsub__Discontinuity) -> Bool {
    if lhs.lastTopicSequence != rhs.lastTopicSequence {return false}
    if lhs.newTopicSequence != rhs.newTopicSequence {return false}
    if lhs.newSequencePage != rhs.newSequencePage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CacheClient_Pubsub__Heartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + "._Heartbeat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CacheClient_Pubsub__Heartbeat, rhs: CacheClient_Pubsub__Heartbeat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
